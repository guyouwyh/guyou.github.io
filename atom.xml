<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>努力走,走到灯火通明</title>
  
  
  <link href="https://guyouwyh.github.io/guyouwyh/atom.xml" rel="self"/>
  
  <link href="https://guyouwyh.github.io/guyouwyh/"/>
  <updated>2022-11-03T03:08:35.448Z</updated>
  <id>https://guyouwyh.github.io/guyouwyh/</id>
  
  <author>
    <name>故犹</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal源码分析</title>
    <link href="https://guyouwyh.github.io/guyouwyh/2022/11/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://guyouwyh.github.io/guyouwyh/2022/11/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-11-02T14:39:00.112Z</published>
    <updated>2022-11-03T03:08:35.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="threadlocal是什么"><a class="anchor" href="#threadlocal是什么">#</a> ThreadLocal 是什么？</h1><p>ThreadLocal 可以理解为一份属于线程的本地变量，其实是一种空间换时间是思想，对于一个共享变量，多个线程要对其操作，那么肯定要加锁，但是加锁的话，就会有性能损耗。换一种思路，如果我们每个线程都有一份变量，那么是不是就没必要加锁了？但是这样会浪费一些空间，这就是空间换时间的思想，也是一种无锁编程的实现方式。即每个线程都有一个属于自己的空间，其他线程无法访问到。起到了线程隔离的作用。</p><h1 id="threadlocal能干什么"><a class="anchor" href="#threadlocal能干什么">#</a> ThreadLocal 能干什么？</h1><ul><li>线程隔离<br /> ThreadLocal 的主要价值在于线程隔离，ThreadLocal 中的数据只属于当前线程，其本地值对别的线程不可见的。在多线程环境下，可以防止自己的变量被其他线程篡改，另外，由于各个线程之间的数据相互隔离，避免了同步加锁带来的性能损失，大大提升了并发性的性能。</li></ul><p>常见的 ThreadLocal 使用场景为数据库连接独享、Session 数据管理等。</p><ul><li>跨函数传递数据</li></ul><p>通常用于同一个线程内，跨类、跨方法传递数据时，如果不用 ThreadLocal, 那么相互之间的数据传递势必要靠返回值和参数，这样无形之中增加了这些类或者方法之间的耦合度。<br />由于 ThreadLocal 的特性，同一线程在某些地方进行设置，在随后的任意地方都可以获取到，线程执行过程中所执行的函数都能读写 ThreadLocal 变量的线程本地值，从而可以方便地实现跨函数的数据传递。<br />在夸函数传递数据的场景中，使用 ThreadLocal 的典型案例为：可以为每个线程绑定一个 Session 信息，这样一个线程所有调用到的代码都可以非常方便地访问这个本地会话，而不需要通过参数传递。</p><h1 id="threadlocal的整体架构"><a class="anchor" href="#threadlocal的整体架构">#</a> ThreadLocal 的整体架构</h1><p><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221102225121.png" alt="" /><br />从这个图中，我们可以看到，ThreadLocal 里面有个内部类，从名字可以看到是个 Map,Map 中又有个 Entry 内部类。可以猜测，我们存到 ThreadLocal 中的数据实际上是存到了 ThreadLocalMap 中。</p><h1 id="threadlocal源码分析"><a class="anchor" href="#threadlocal源码分析">#</a> ThreadLocal 源码分析</h1><p>先介绍 ThreadLocal 的 set () 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token comment">// 获取当前线程</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 从当前线程 Thread 中获取 ThreadMap</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 如果 map 已经被初始化</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 则将当前 ThreadLocal 作为 key,value 作为值，放到 map 中</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 如果 map 没有被初始化，则初始化 map, 并把当前 ThreadLocal 和 value 作为一个 entry 加入进去</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token class-name">ThreadLocalMap</span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>       <span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">,</span> <span class="token class-name">T</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 可以看到直接初始化，new 了一个 ThreadLocalMap</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从 set 方法中，我们可以知道，ThreadLocal 的 set 其实是委托给 ThreadLocalMap 进行的。</p><p>接着看 ThreadLocal 的 get () 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 获取当前线程</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 跟 set 一样，获取当前线程变量中的 ThreadLocalMap</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 如果 map 已经被初始化了，就直接根据当前 ThreadLocal 获取 Entry</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token class-name">ThreadLocalMap<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token comment">// 如果这个 entry 不为空，直接返回</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token class-name">T</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 到这一步，要不就是 map 没有被初始化，要不就是获取的 entry 为 null, 这里是返回初始值。</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接下来可以看一下 setInitialValue () 这个方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">T</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 这里又调用了另外一个方法获取一个 value</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">T</span> value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 下面的操作其实跟 set 差不多，就将这个值设置进去</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>继续进入 initialValue () 这个方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果是第一次看到这个方法，会很疑惑，为什么直接就返回 null 了？那么其实可以想一下，肯定是有子类重写了这个方法。之后会讲解之类是怎么回事。</p><p>接下来看一下 withInitial () 源码:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">></span></span> <span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">S</span><span class="token punctuation">></span></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SuppliedThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>嗯？怎么这个方法，传入了一个供给者接口参数，然后又 new 了一个 SuppliedThreadLocal? 点进去看看。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SuppliedThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> supplier<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">SuppliedThreadLocal</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>supplier <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">protected</span> <span class="token class-name">T</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看到这大概就明白了，这是一个 ThreadLocal 的子类，里面保存了个这个供给者接口，然后重写 initialValue () 方法，在这个方法中调用 supplier 函数。<br />那么 withInitial () 其实是返回一个 ThreadLocal 的子类，这个子类带有一个初始值。</p><h1 id="threadlocalmap源码分析"><a class="anchor" href="#threadlocalmap源码分析">#</a> ThreadLocalMap 源码分析</h1><p>ThreadLocalMap 是 ThreadLocal 中的一个内部类。<br />先看看这个内部类的一些基础属性:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 内部类 Entry, 继承了一个弱引用</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            </pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token class-name">Object</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 这里是将 ThreadLocal--- key 作为弱引用</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                value <span class="token operator">=</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 初始容量</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 哈希数组</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 当前的 entry 数目</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 扩容阈值</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 设置扩容阈值</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            threshold <span class="token operator">=</span> len <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里可以看到，其实 ThreadLocalMap 就是一个简单的 Map, 这里可以发现，Entry 的 key 居然是一个弱引用，之后会讲解这里为什么是弱引用。<br />接下来看看，构造函数:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> firstKey<span class="token punctuation">,</span> <span class="token class-name">Object</span> firstValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                <span class="token comment">// 初始化哈希数组</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                <span class="token comment">// 计算下标</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token comment">// 初始化数组下标的 entry</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment">// 设置扩容阈值</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token function">setThreshold</span><span class="token punctuation">(</span>INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接下来看看 set 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token comment">// 先获取一下哈希数组</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token comment">// 数组的长度</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 哈希到数组的某个下标，&amp; 是二进制优化 %</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token comment">// 从哈希的下标开始，遍历，如果位置不为空，就执行方法体</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                 e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                 e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 获取一下键值</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 如果找到了相同的 ThreadLocal, 直接替换值</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token comment">// 如果 ThreadLocal 为 null, 说明被清理了，重新设置 entry</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 执行到这，说明已经找到空位了，直接赋值</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token comment">//size++</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token comment">// 这里是清理空的槽，如果没有需要清理的，并且 entry 的数量达到扩容阈值，就会进行扩容</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>set 方法的整体流程不是很难理解，其实就是使用一种开放定地址的哈希方法，先哈希到数组的某一个下标 i, 然后从 i 开始，找到一个空的槽位，如果槽位不为空就匹配下 key 是不是相等，如果 key 匹配或者 key 为 null, 就可以直接替换。如果找到了一个空槽位，就直接 new 一个 Entry, 最后是看看有没有空的槽位需要清理的，如果没有并且 entry 数量达到了扩容阈值，那么就会进行扩容。<br />这里需要注意一下 nextIndex 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看到这个方法，其实可以理解为一个循环一样，如果要超出哈希数组的大小，就又从 0 开始了。<br />下面介绍下 getEntry 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token class-name">Entry</span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token comment">// 如果 e 不为空并且 e 的 key 值匹配，直接返回</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">return</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 如果 e 为 null 或者 e 的 threadLocal 不匹配，调用这个方法</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>继续看看 getEntryAfterMiss 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Entry</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">Entry</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>                <span class="token comment">// 这里的逻辑，也是从 i 往后找，因为可能 set 的时候，也并不一定是在哈希地址 i 位置进行设置的</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    <span class="token comment">// 如果 k 为 null, 删除这个 entry</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">else</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 如果 e 为 null, 那么肯定就说明 map 中没有该 ThreadLocal 对应的的 entry 了。</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>继续看看 expungeStaleEntry 方法，友情提示，expunge 中文意思就是删除。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>           <span class="token comment">// 将位置为 i 的 value 设置为 null</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 将位置为 i 的数组元素直接设置为 null, 这里其实是为了清除 entry 中 key 为 null 的 entry</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 重新哈希，直到遇到 null</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">Entry</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 从 stateSlot 后一个元素开始遍历</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                 <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                 i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token comment">// 如果 threadLocal 为 null</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token comment">// 继续释放引用</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                    size<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    <span class="token comment">// 如果 key 不为空，重新哈希</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                    <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                    <span class="token comment">// 如果哈希的位置不是当前 i 的位置，那么就将当前 i 的位置设置为 null</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>                        <span class="token comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                        <span class="token comment">// null because multiple entries could have been stale.</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                        <span class="token comment">// 从 h 位置开始，直到找到一个 null, 就将 entry 移到这个 null 的位置</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                        <span class="token keyword">while</span> <span class="token punctuation">(</span>tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                            h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                        tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token keyword">return</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个方法其实就是为了清除一些 key 为空 (ThreadLocal 已经被回收) 的 entry, 那么为什么 ThreadLocal 会被回收呢？之前说了一下 entry 中的 key (ThreadLocal) 是弱引用，弱引用有个特点，只能存活到下一次 GC, 下一次 GC 无论内存紧不紧张，都会被回收，因此就会出现很多 key 为 null 的 entry, 由于整个 entry 中还有个 value, 因此 entry 不会被回收，所以在每次 get、set 方法的时候，就会将那些 key 为 null 的 entry 进行清空，方便 GC 回收，防止内存泄露。这个方法在回收之后，还进行了一次重新哈希。<br />现在又回到 set 方法，可以看一下 cleanSomeSlots 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token keyword">boolean</span> removed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    n <span class="token operator">=</span> len<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    removed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    <span class="token comment">// 这里也调用了 expungeStaleEntry 方法</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    i <span class="token operator">=</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>n <span class="token operator">>>>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">return</span> removed<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，在 set 的时候，也会调用 expungeStaleEntry 方法清除 key 为 null 的 entry。</p><p>接下来看看 remove 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 这行代码是不是很熟了？</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                 e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                 e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    e<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    <span class="token comment">// 又开始清理 key 为 null 的 entry 了</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里就可以做个总结了，getEntry、remove、set 方法，里面都调用了一个 expungeStaleEntry, 这个方法其实是为了防止内存泄露，清理掉 key 为 null 的 Entry。</p><p>最后看看 rehash 和扩容</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token comment">// 清楚 key 为 null 的 entry</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// Use lower threshold for doubling to avoid hysteresis</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 如果大于等于 3/4 的扩容阈值</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 直接扩容</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>还记不记得之前的 threhold 是 2/3 的容量？这里有使用了一个 3/4threshold, 这样算的话就是 1/2, 为了避免浮点数精度问题。下面继续看看 resize 函数</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">int</span> oldLen <span class="token operator">=</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token comment">// 两倍扩容</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">int</span> newLen <span class="token operator">=</span> oldLen <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newLen<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldLen<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token class-name">Entry</span> e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token comment">// 如果是空，直接将 value 设置为 null</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                        e<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// Help the GC</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                        <span class="token comment">// 不为空</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                        <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                        <span class="token comment">// 老规矩，计算哈希位置然后循环往下找</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                        <span class="token keyword">while</span> <span class="token punctuation">(</span>newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                            h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                            <span class="token comment">// 找到一个空位</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                        newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                        count<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// 设置新的容量的扩容阈值</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token function">setThreshold</span><span class="token punctuation">(</span>newLen<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            size <span class="token operator">=</span> count<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token comment">// 使用扩容后的哈希数组</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            table <span class="token operator">=</span> newTab<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段扩容代码非常好理解，两倍扩容，从就数组上重新哈希到新数组上即可。</p><p>源码分析的差不多了，那么就说明一下，entry 中的 key 为什么要使用弱引用的问题吧！<br /><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221103110817.png" alt="" /><br /> 先来说说，如果 entry 中的 key 是强引用会怎么样，我们应该都知道，在虚拟机栈中的基本单位是栈帧，每一个方法的使用其实都对应着一个栈帧的入栈和出栈，如果我们在方法中 new 了一个 ThreadLocal, 实际上，会在堆中分配一个内存，初始化 Thread。那么在 funcA 中引用 ThreadLocal 的变量肯定是强引用，那么此时堆中还有一个 ThreadLocalMap, 内部类 entry 中的 key 引用 ThreadLocal,value 引用 Object 对象，假设前者是强引用，当方法结束，栈帧出栈，局部变量被销毁，即 funcA 中的变量指向 ThreadLocal 的引用消失。那么如果 key 也是强引用，那么 ThreadLocal 就不能被回收，即使线程消亡，ThreadLocal 也不会被回收，当然还有 value 指向的 Object, 因此会存在内存泄露。<br />在看看 entry 中的 key 如果是弱引用的情况，弱引用对象只能存活到下一次垃圾回收之前，因此，即下一次垃圾回收，key 就会变为 null, 如果线程结束，ThreadLocal 就会被回收，但是还有个 value, 不会被回收。之前分析过，当 getEntry、set、remove 方法，其实都会找到 key 为 null 的 entry, 释放 value 指向 Object 的引用，帮助 GC。这就是弱引用的好处。</p><h1 id="threadlocal发生内存泄露的前提"><a class="anchor" href="#threadlocal发生内存泄露的前提">#</a> ThreadLocal 发生内存泄露的前提</h1><ul><li><p>线程长时间运行而没有被销毁，线程池中的 Thread 实例很容易满足此条件，因为每个线程都有自己的一个虚拟机栈，如果线程运行，虚拟机栈中每个栈帧对应一个方法，方法没有停止运行，此时有局部变量一直引用 ThreadLocal, 就会发生内存泄露。</p></li><li><p>ThreadLocal 引用被设置为 null, 且后续在同一个 Thread 实例执行期间，没有发生对其他 ThreadLocal 实例的 get ()、set () 或者 remove () 操作，只要存在一个针对任何 ThreadLocal 实例的 get、set 或 remove 操作，就会触发 Thread 实例拥有的 ThreadLocalMap 的 Key 位 null 的 Entry 清理工作，释放掉 ThreadLocal 弱引用为 null 的 Entry。</p></li></ul><h1 id="threadlocal的规范"><a class="anchor" href="#threadlocal的规范">#</a> ThreadLocal 的规范</h1><p><strong>使用 static final 修饰 ThreadLocal,static 的目的是为了被所有对象共享。由于静态变量会在类第一次被使用时装载，只会分配一次存储空间，此类的所有实例都会共享这个存储空间，所以使用 static 修饰 ThreadLocal 就会节约空间。final 的目的是为了保证 ThreadLocal 实例的唯一性，除了使用 static 修饰之外，还会使用 final 进行修饰，以防止起在使用过程中发生动态变更。<br />由于静态变量的存储在方法区，ThreadLocal 实例是在堆，方法区和堆都是各个线程共享的。并且静态变量只会初始化一次，所以所有线程都是使用同一个 threadLocal, 但是由于每个线程都有各自的 ThreadLocalMap, 也就是说，相同的 ThreadLocal 存储在不同的 ThreadLocalMap 中。这样比每一个线程都要在堆中 new 一个 ThreadLocal 更加节约内存。<br />但是使用 static final 会造成一些问题，就是在线程生命周期内，ThreadLocalMap 中的 key 不会为 null, 这里注意一下，弱引用对象能被下次 GC 回收的前期条件是弱引用的对象只存在弱引用，不存在强引用。如果是 static final, 那么 ThreadLocal 会一直存在一个强引用，GC 就不会回收弱引用指向的对象，从而 key 不会为 null, 那么 entry 中的 value 也不会被垃圾回收，因此每次使用完后需要手动 remove。</strong></p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p><strong>以上就是 ThreadLocal 的基本原理和源码分析，需要注意的点是，ThreadLocal 中的哈希表使用的是开放定地址法，并不是拉链法，并且 map 中的 key 是弱引用，ThreadLocalMap 中的扩容阈值其实是 1/2 容量大小，并且 get、set 和 remove 方法都会自动清理 key 为空的 entry, 仔细品味这些细节，会学习到很多思想和知识。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;threadlocal是什么&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#threadlocal是什么&quot;&gt;#&lt;/a&gt; ThreadLocal 是什么？&lt;/h1&gt;
&lt;p&gt;ThreadLocal 可以理解为一份属于线程的本地变量，其实是一种空间换时间是思想，对</summary>
      
    
    
    
    <category term="后端" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ReentryLock源码分析</title>
    <link href="https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ReentryLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ReentryLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-11-01T13:09:30.020Z</published>
    <updated>2022-11-02T06:30:32.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reentrylock的继承链"><a class="anchor" href="#reentrylock的继承链">#</a> ReentryLock 的继承链</h1><p><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221101211500.png" alt="" /></p><p><ins>可以看到，ReentrantLock 实现了 Lock 接口，有一个抽象内部类 Sync, 其继承了 AbstractQueuedSynchronizer 同步器，并且抽象内部类也有两个实现，一个是 FairSync, 一个是 NonFairSync。</ins></p><p><strong>在分析 ReentrantLock 源码之前，先说一些关于锁的前置知识。</strong></p><h1 id="锁的可重入"><a class="anchor" href="#锁的可重入">#</a> 锁的可重入</h1><p>那么问题来了，什么是锁的可重入呢？<br /> 当我们获取到了一把锁，能不能再次获取这把锁，这就叫锁的可重入，显然，如果锁不能重入的话，那么很容易发生死锁。</p><h1 id="锁的设计思路"><a class="anchor" href="#锁的设计思路">#</a> 锁的设计思路</h1><p>如果要实现一个锁的功能，必须要思考一下几个核心要素:</p><ol><li>需要一个变量去标记锁的状态，当获取锁时，这个变量增加，当释放锁时，这个变量减少，由于可能会有多个线程对变量进行操作，所以必须使用 CAS.</li><li>需要记录当前持有锁的线程，如果不记录的话，无法实现锁重入</li><li>需要操作系统底层的一些操作对线程进行阻塞或者唤醒。</li><li>需要一个队列维护阻塞的线程，这个队列也必须是线程安全的。</li></ol><h1 id="公平锁和非公平锁的概念"><a class="anchor" href="#公平锁和非公平锁的概念">#</a> 公平锁和非公平锁的概念</h1><p>基于上述的锁的实现思路，现在来说明一下什么是公平锁，什么是非公平锁。</p><ul><li><p>公平锁：顾名思义，即抢锁是公平的，就好比我们去排队买奶茶，肯定要排队，只有前面一个人买完奶茶，我们才能去买。对应的在阻塞队列中，只有作为阻塞队列队首的元素才能去抢锁。</p></li><li><p>非公平锁：即抢锁是不公平的，同样是去买奶茶，有些素质低的人，在队首的人买完奶茶后，直接去插队买奶茶。对应在阻塞队列中，如果持有锁的线程释放了锁，阻塞队列中的所有线程都可以去抢锁。</p></li></ul><p>一些锁的基础概念介绍完了，接下来就开始进行 ReentrantLock 的源码分析了:</p><h1 id="lock接口"><a class="anchor" href="#lock接口">#</a> Lock 接口</h1><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 获取锁，获取不到会阻塞</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 获取锁的过程中可以响应中断</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 尝试去获取锁，只会获取一次，即不会阻塞</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 在一定时间内获取不到所就返回</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 解锁</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 等待队列</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意一下带 try 的，try 开头的是尝试去获取锁，也就是只会获取一次。可以看到返回的 boolean 表示锁是否获取到。</p><p>在分析 ReentrantLock 之前，还需要说一下 AQS, 但是在说 AQS 之前，需要了解的一个前置知识是：CLH 自旋锁。</p><h1 id="clh锁"><a class="anchor" href="#clh锁">#</a> CLH 锁</h1><p>CLH 锁其实是一种基于队列 (具体为单向链表) 排队的自旋锁，是由 Craig、Landin 和 Hagersten 三人一起发明的，因此被命名为 CLH 锁，也叫 CLH 队列锁。</p><p>实现思路：申请加锁的过程首先会通过 CAS 操作在单向链表的尾部增加一个节点，之后该线程只需要在其前驱节点上进行普通自选，等待前驱节点释放锁即可，由于 CLH 锁只有在节点入队时进行一下 CAS 操作，在节点加入队列之后，抢锁线程不需要进行 CAS 自旋，只需要普通自旋，因此，在争用激烈的场景下，CLH 锁能大大减少 CAS 操作的数量，以避免 CPU 总线风暴。</p><blockquote><p>CLH 锁的原理分析</p></blockquote><ol><li>初始化队列尾部属性 tail 指向一个空节点，tail 最好使用 AtomicReference 包装，为了避免多个线程并发操作 tail 时不会发生线程安全问题</li><li>Thread 在抢锁时候会创建一个新的 Node 节点加入等待队列尾部:tail 指向新的 Node, 同时新的 Node 的 preNode 属性指向 tail 之前指向的节点，并且以上操作通过 CAS 自旋完成，以确保操作成功。</li><li>Thread 加入抢锁队列后，会在前驱节点上自旋：循环判断前驱节点的 locked 属性是否为 false, 如果为 false 就表示前驱节点释放了锁，当前线程抢占到锁。</li><li>Thread 抢到锁之后，它的 loacked 属性一直为 true, 一直到临界代码执行完成，然后调用 unlock 方法释放锁，释放之后其 locked 属性才为 fasle。</li></ol><blockquote><p>CLH 锁的优缺点<br />优点：空间复杂度低，如果有 N 个线程，L 个锁，那么需要的存储空间是 O (L+N)<br /> 缺点：在 NUMA 架构的 CPU 平台上性能很差，CLH 队列所在 NUMA 架构的 CPU 平台上，每个 CPU 内核有自己的内存，如果前驱节点在不同的 CPU 内核上，它的内存位置比较远，在自旋判断前驱节点的 locked 属性时，性能将大打折扣，然后，CLH 所在 SMP 结构的 CPU 平台上则不存在这个问题。</p></blockquote><h1 id="aqs中的node节点"><a class="anchor" href="#aqs中的node节点">#</a> AQS 中的 Node 节点</h1><p>AQS 中是一个 CLH 队列，不存在队列实例，仅存在节点之间的前后关系。Node 节点中核心成员源码如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">//1 取消状态</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">//-1 标识后继线程处于等待状态</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">//-2 标识当前线程正在进行条件等待</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">//-3 标识下一次共享锁 acquireShared 操作需要无条件传播</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 节点状态：值为 SIGNAL、CANCELLED、CONDITION、PROPAGATE、0</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 普通节点的同步节点状态的初始值为 0, 条件等待节点的初始值为 CONDITION (-2)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 前驱节点，当前节点会在前驱节点上自旋，循环检查前驱节点的 waitStatus 状态</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 后继节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    </pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 若当前 Node 不是普通节点而是条件等待节点，则节点处于某个条件的等待队列上，此属性指向下一个等待节点，即条件队列上的后继节点。</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>waitStatus 属性</strong><br />每个节点与等待线程关联，每个节点维护一个状态 waitStatus,waitStatus 的各种值以常量的形式进行定义。waitStatus 的各常量值具体如下:</p><ul><li><p>CANCELLED=1<br />waitState 值为 1 时，表示该线程节点已释放 (超时、中断), 已取消的节点不会再阻塞，表示线程因为中断或者等待超时，需要从等待队列中取消等待。</p></li><li><p>SIGNAL=-1<br />waitStatus 为 SIGNAL (-1) 时表示其后继的节点处于等待状态，当前节点对应的线程如果释放了同步状态或者被取消，就会通知后继节点，使后继节点的线程得以运行</p></li><li><p>CONDITION=-2<br />waitStatus 为 - 2 时，表示该线程在条件队列中阻塞 (Condition 有使用), 表示节点在等待队列中 (这里指的是等待在某个锁的 CONDITION 上), 当持有锁的线程调用了 CODITION 的 signal () 方法之后，节点会从该 CONDITION 的等待队列转移到该锁的同步队列上，去竞争锁。<br />节点处于等待队列中，节点线程等待在 CONDITION 上，当其他线程对 CONDITION 调用了 signal () 方法后，该节点从等待队列中转移到同步队列中，加入对同步状态的获取中。</p></li><li><p>PROPAGATE=-3<br />waitStatus 为 - 3 时，表示下一个线程获取共享锁后，自己的共享状态会被无条件地传播下去，因为共享锁可能出现同时有 N 个锁可以用，这时直接让后面的 N 个节点都来工作。<br />为什么当一个节点的线程获取共享锁后，要唤醒后继共享节点？共享锁是可以多个线程共有的，当一个节点的线程获取共享锁后，必然要通知后继共享节点的线程也可以获取锁了，这样就不会让其他等待的线程等很久，这种向后通知的目的也是尽快同同志其他等待的线程尽快释放锁</p></li><li><p>waitStatus 为 0<br /> 表示当前节点处于初始状态。<br />Node 结点的 waitStatus 状态为以上 5 中状态的一种。</p></li></ul><p><strong>抢占类型常量标识</strong><br /> Node 节点还定义了两个抢占类型常量标识：SHARED 和 EXCLUSIVE, 具体如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>       <span class="token comment">// 标识节点在抢占共享锁</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 标识节点在抢占独占锁</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> EXCLUSIVE <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>SHARED 表示线程是因为获取共享资源时阻塞而被添加到队列中的，EXCLUSIVE 表示线程是因为获取独占资源时阻塞而被添加到队列中的。<br />介绍完 Node 节点后，接下来就开始 AQS 的正题了。</p><h1 id="aqs独占锁"><a class="anchor" href="#aqs独占锁">#</a> AQS 独占锁</h1><p>先从 aquire 方法源码分析:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>         <span class="token comment">// 尝试去获取锁，如果没获取成功，就会执行后面的</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 这里首先是将一个独占节点加入到阻塞队列中，然后在 acquireQueued 中继续获取一次锁，获取失败就阻塞</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 注意，acquireQueued 返回的是一个打断标记，如果为 true 将会执行下面的语句</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 这个是传播打断标记</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，这里的代码非常有艺术，使用 &amp; 的特性，如果前面一个函数返回 true, 才会执行后面的函数，也就是如果获取锁失败，那么就会直接执行后面的函数。<br />接下来进入 tryAcquire 方法中，由于 ReentrantLock 中有两种 AQS 的实现，一个是公平锁的，一个是非公平锁的，这里先介绍非公平锁的的 tryAcquire 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token comment">// 获取当前线程</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 获取当前状态</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 如果状态为 0, 说明没有其他线程获取锁</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 使用 CAS, 尝试去修改状态</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    <span class="token comment">// 修改状态成功，即成功获取了锁，将当前线程保存起来</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token comment">// 返回 true, 表示获取锁成功</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 如果状态不为 0, 先判断一下当前线程是否是持有锁的线程，这里是为了锁重入</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 执行到这，说明没有获取锁，直接返回 false</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果 tryAcquire 方法返回 false, 说明尝试 CAS 获取锁失败，直接就会进入 addWaiter 的逻辑:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 这里的 mode, 其实传入的是一个空节点，代表独占节点，通过构造函数将当前线程传入进去</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 这里先是获取尾节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 如果尾节点不为空</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 将当前节点的前驱指向尾节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 将尾节点指针使用 CAS 指向当前节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 如果成功，那么原来的尾节点，也就是前驱节点的 next 指针指向当前节点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 返回当前节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">return</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 执行到这里，表示尾节点为空或者 cas 替换尾节点失败，即由其他线程冲突，进入 enq 方法</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其实这个方法，就是构造 Node 节点，然后尝试 CAS 替换尾节点，如果替换失败则进入 enq 方法，下面来看看 enq 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 死循环</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token comment">// 获取尾节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 如果尾节点为空，则代表没有初始化</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Must initialize</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 直接通过 CAS 设置一个空的头结点，然后尾节点也指向头结点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    tail <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 进入到这一步，说明尾节点不为空</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 将当前节点的前驱节点设置为尾节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token comment">// 这里相当于再次重试将尾节点指针指向当前节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token comment">// 如果成功，设置之前的尾节点的 next 指针指向当前节点 (现在的尾节点)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    <span class="token comment">// 直接返回</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token keyword">return</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在 enq 中，采用了一个自旋的方式，如果队列未初始化，就构造一个新的头结点进行初始化，然后第二轮循环就会进入到 else 中，然后就相当于一个不断的 CAS 尝试替换尾节点的操作，只有当替换成功后才能返回。再次回到 addWaiter 方法，enq 方法之后是返回 node, 那么可以得出一个结论，队列其实是在 enq 方法中进行初始化的，并且 enq 方法一定会将节点加入阻塞队列。</p><p>接下来就回到 acquireQueued 方法，由于 addWaiter 已经返回了加入阻塞队列中的节点，这时候就可以分析 acquireQueued 方法了:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 死循环</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 由于 node 已经加入阻塞队列，根据 CLH 队列的特性，必定会自旋前驱节点，因此这里先获取一下前驱节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token comment">// 如果前驱节点是头结点，由于头结点其实是个空节点，然后就会再次获取锁</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token comment">// 到这一步，已经获取锁成功了</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token comment">// 直接将当前节点设置为头结点，但是要清空前驱节点和线程，具体看 setHead 方法</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token comment">//p.next 是之前的头结点，这样就不存在引用了，会被 GC 垃圾回收掉</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token comment">// 设置标记，标识不需要取消获取</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token comment">// 直接返回中断标记，目的是为了传播中断</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token comment">// 走到这一步，说明前期节点不是头结点或者尝试获取锁失败，这里要进入一下阻塞的逻辑</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>     <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NullPointerException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token class-name">Node</span> p <span class="token operator">=</span> prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token keyword">return</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>         <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        head <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里还要分析一下 shouldParkAfterFailedAcquire 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 由于 pred 就是 node 节点的前驱，这里是为了获取前驱节点的 waitStatus.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 如果前驱节点的状态是 SIGNAL 状态</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 直接返回 true,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 如果 ws 大于 0, 则说明前驱节点是 CANCEL 取消状态</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token comment">// 这一步，首先是 pred 变量指向前驱节点的前驱节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 然后当前节点的前驱节点指针指向 pred, 通俗来说，就是前驱节点被取消了，当前节点的前驱节点连上了前驱节点的前驱节点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 继续检查前驱节点的状态</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 最后将前驱节点的 next 指针指向当前节点。</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 这里就是 0、-2、-3 状态了，也就是普通节点状态和 PROPAGATE 状态</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 这里将前驱节点的 waitStatus 状态设置为 SIGNAL, 即前驱节点释放锁后会唤醒当前节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 返回 false</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里其实涉及到了对节点状态的判断，如果 ws==Node.SIGAL 节点，那么就说明当前已经不是第一次进入这个函数了，需要阻塞住。<br />如果是第一次进入这个函数:<br /> 前驱节点的状态如果是 1, 也就说前驱节点被取消，那么就会继续往前找到新的前驱结果，然后返回 false. 不需要阻塞<br />前驱节点的状态是 0、-2、-3, 那么设置前驱节点的状态为 - 1, 也就是 SIGAL。不需要阻塞。</p><p>接下来进入真正实现阻塞逻辑的函数 parkAndCheckInterrupt ()</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 阻塞当前线程</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 当被唤醒的时候，通过 Thread.interrupted 判断是被打断还是被 unpark</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个函数比较好理解，回到之前:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果 parkAndCheckInterrupt 返回 true, 说明打断标记为 true, 也就是被打断的，将 interrupt 设置为 true, 传播打断标记。<br />接下来进入最后一个方法:cancelAcquire</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 如果节点不存在，直接返回</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 节点存在，将保存的线程设置为 null</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 获取前一个节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Node</span> pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 状态大于 0, 一定是 1, 即 Cancel 状态，继续往前遍历</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 获取前一个节点的 next 节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">Node</span> predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 设置节点的状态为取消状态</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 如果节点的尾节点，则将尾节点指针用 CAS 替换到前一个节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 替换成功后，由于取消尾节点，那么前一个节点的 next 节点要设置为 null</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 如果节点不是尾节点</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">int</span> ws<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>             <span class="token comment">// 如果前驱节点不是 head, 并且，前驱节点的 waitStatus 状态为 SIGNAL 或者是 前驱节点状态 & lt;=0，并且能将前驱节点的状态修改为 SIGNAL</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL <span class="token operator">||</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                 <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                    <span class="token comment">// 先获取当前节点的后继节点</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token class-name">Node</span> next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                <span class="token comment">// 如果存在后继节点，并且状态小于等于 0 (-3, -2 ,-1 ,0)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                <span class="token comment">// 将前驱节点的的 next 设置为当前节点的后继节点</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                    <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token comment">// 当前前驱节点为 head 节点的时候，唤醒当前节点</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment">// help GC</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个方法的逻辑就是取消节点，其实就是将节点状态修改为 CANCEL (1), 要先检查前驱节点是否也为 CANCEL, 往前找到第一个不为 CANCEL 状态的前驱节点，目的是为了将当前节点从后继节点移除，但是如果当前节点的前驱节点就是 head, 那么则会唤醒当前节点，重新竞争一下锁。<br />这个方法的发生时机应该是处于异常的时候，因为它处于 finally 块中。<br />下面来看一下真正唤醒的方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 获取要唤醒节点的状态</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 如果 waitStatus&lt;0, 那么 waitStatus 状态只能是 - 1 (SIGNAL)、-2 (CONDITION)、-3 (PROGATION)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>         <span class="token comment">// 这里是直接将节点状态替换为正常节点，也就是说，除了 CANCEL 状态，都要恢复成初始节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 获取下一个节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 如果当前 node 是尾节点或者 next 节点等待状态 > 0 (处于 CANCEL 状态)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 从尾节点开始，遍历到当前的 node 节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 这里找到 node 之后第一个非取消的节点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    s <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 如果 s 不为空</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 唤醒 s 的线程</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从实现逻辑中可以看出，unparkSuccessor (node) 唤醒的并不是 node 节点，而是 node 节点之后的第一个非取消状态的节点。<br />这时候，可以回过头看看 acquireQueued 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 死循环</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>               </pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>              </pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                   </pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                   </pre></td></tr><tr><td data-num="16"></td><td><pre>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                   </pre></td></tr><tr><td data-num="18"></td><td><pre>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    </pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// 节点会从 parkAndCheckInterrupt 方法中醒来，由于是 unpark 唤醒的，因此会返回 false, 不会执行 interrupted = true;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token comment">// 然后继续进入死循环，也就是自旋前驱节点，尝试获得锁。</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接下来分析一下释放锁的逻辑，可以看到 release 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 尝试去释放锁，即通过 CAS 修改状态 state</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 如果释放锁成功，</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 获取头结点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 如果头结点不为空并且非 0</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 唤醒后继节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>进入 tryRelease 方法中:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            </pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">return</span> free<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码不难理解，可以发现并没有使用 CAS, 这是因为锁是独占锁，获取锁的线程只有一个，因此不存在线程安全问题。直接修改状态即可。<br />以上都是非公平锁的实现方式。</p><p>下面看看公平锁的获取方式:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token comment">// 这里多了个 hasQueuedPredecessors 方法判断是否有前驱节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                    <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// The correctness of this depends on head being initialized</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// before tail and on head.next being accurate if the current</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// thread is first in queue.</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// Read fields in reverse initialization order</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">Node</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 如果节点个数大于 1 个，并且头节点的 next 不指向当前节点，就说明不能获取锁，要排队！！！</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以发现，非公平锁就多了个 hasQueuedPredecessors, 只要前驱节点是头结点，才能获取锁。保证了公平性。</p><p>到这里，AQS 独占锁源码解析就差不多了，但是还有个共享锁并没有分析，由于 ReentrantLock 是独占锁，所以本篇不再叙述共享锁。<br />那么做一个 AQS 独占锁的小总结:++ 首先，AQS 是一个同步器，它是由并发大师 DougLea 开发的，内部维护了一个 CLH 变种队列，使用了一种模板方法设计模式，也就是如果要实现自定义的组件，可以聚合 AQS 同步器，委托给 AQS 同步器去做，核心原理就是将线程包装成一个个队列节点，首节点代表获取锁的线程节点，通过对 state 状态变量进行 CAS 操作，如果 CAS 失败，则通过 addWaiter 方法加入同步队列，在加入同步队列的方法中，有个 enq 方法，思路是使用自旋也就是死循环的方式，将节点加入队尾。加入完后返回当前节点，调用 acquireQueued 方法，传入当前节点作为形参，这个方法的思路是处于一个死循环中，再次重新获取一下锁，如果失败，需要判断一下是否符合阻塞的条件，如果符合，则调用 Unsafe.park 方法阻塞住，否则就不阻塞。阻塞需要等待唤醒，唤醒之后继续死循环。+<br />+</p><h1 id="reentrantlock源码解析"><a class="anchor" href="#reentrantlock源码解析">#</a> ReentrantLock 源码解析</h1><p>下面正式进入 ReentrantLock 源码解析:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7373984872572414699L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 聚合了一个 Sync</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//sync 是一个内部类，可以看到继承了 AQS</span></pre></td></tr><tr><td data-num="7"></td><td><pre>     <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5179523762034025860L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>     <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     <span class="token comment">// 又有一个 Sync 实现内部类，从名字可以看出，是非公平锁的实现</span></pre></td></tr><tr><td data-num="12"></td><td><pre>       <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7316153563782823691L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>     </pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 公平锁</span></pre></td></tr><tr><td data-num="29"></td><td><pre>       <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3000897897090466540L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                    <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre></pre></td></tr><tr><td data-num="57"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>继续看一下构造方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，这里有两个构造方法，无参构造默认的 sync 实现是非公平锁，有参构造是根据传入的 fair, 去判断是用公平锁还是非公平锁<br />继续看看 lock 接口定义的方法实现:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 这里直接委托给了 sync 的 lock 方法</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 这里也是委托给 sync</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看到这里，其实整个 ReentrantLock 就十分清晰了，所有方法都是委托给 AQS, 由于 AQS 定义了一些抽象方法比如 tryAcquire, 这些方法都在 ReentrantLock 的内部类 NonFairSync 和 FairSync 中实现了，也就是其实 ReentrantLock 中也就实现了 AQS 中的抽象方法，通过这些抽象方法对 state 变量进行操作，而到达实现各种组件的目的。这也就是模板方法设计模式的好处。</p><p>下面介绍一下 ConditonObject, 相信使用过 ReentrantLock 都不会陌生，这个是个等待队列，可以实现 wait/notify 一样的效果。那么下面来看看源码:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其实这个方法是在 Lock 接口中定义的，在 ReenrantLock 中实现的:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，其实也是委托给了 sync。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionObject</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1173984872572414699L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 等待队列中的头节点</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 等待队列中的尾节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里其实直接 new 了一个 ConditonObject, 这个类是一个内部类，可以到这个类其实是个双向链表。这个类实现了 Condition 接口:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Condition</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span><span class="token class-name">Date</span> deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>下面看看这些方法的具体实现，首先是 await () 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token comment">// 先检查线程的中断标志，如果被中断，直接抛出异常</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                </pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token comment">// 将节点添加到等待队列中</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 释放当前节点线程持有的锁 (将 state 修改为 0), 这里需要保存下锁状态</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 如果不在阻塞队列</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 直接阻塞</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 执行到这说明被唤醒或者之前的 while 判断在阻塞队列中，尝试去获取锁</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token comment">// 如果该节点后还有等待队列，清理下被取消的节点</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token comment">//</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token comment">// 等待队列中的尾节点</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token class-name">Node</span> t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token comment">// If lastWaiter is cancelled, clean out.</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token comment">// 如果尾节点不为空，并且尾节点的的 waitStatus 不是 CONDITION (-2), 说明尾节点取消</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token comment">// 重新定位尾节点</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token comment">// 如果尾节点为空，说明等待队列为空，新建一个 waitStatus 状态为 CONDITION 的节点</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token comment">// 如果尾节点为空</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token comment">// 当前节点就作为队列的第一个节点，firstWaiter 指针指向它</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                <span class="token comment">// 如果尾节点不为空，则尾节点的 nextWaiter 指向当前新建节点</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                <span class="token comment">// 尾节点指针也指向当前节点</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token keyword">return</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>            <span class="token comment">// 这个函数的作用是，取消状态不为 CONDITION 的节点，将剩余的节点重新链接起来</span></pre></td></tr><tr><td data-num="54"></td><td><pre>           <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>            <span class="token class-name">Node</span> t <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>            <span class="token class-name">Node</span> trail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>                <span class="token comment">// 遍历</span></pre></td></tr><tr><td data-num="59"></td><td><pre>                <span class="token class-name">Node</span> next <span class="token operator">=</span> t<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>                <span class="token comment">// 从头开始遍历，如果找到状态不为 CONDITION 的节点</span></pre></td></tr><tr><td data-num="61"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>                    t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>                    <span class="token comment">///trail 为空</span></pre></td></tr><tr><td data-num="64"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>trail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="65"></td><td><pre>                    <span class="token comment">// 头结点指直接指向 t 的后继节点。</span></pre></td></tr><tr><td data-num="66"></td><td><pre>                        firstWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>                    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="68"></td><td><pre>                    <span class="token comment">//trail 不为空，移除当前的 t,trail 的后继 waiter 指向 next</span></pre></td></tr><tr><td data-num="69"></td><td><pre>                        trail<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="71"></td><td><pre>                        lastWaiter <span class="token operator">=</span> trail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>                <span class="token comment">// 如果是 CONDITION 节点</span></pre></td></tr><tr><td data-num="74"></td><td><pre>                <span class="token keyword">else</span></pre></td></tr><tr><td data-num="75"></td><td><pre>                <span class="token comment">//trail 即是当前节点</span></pre></td></tr><tr><td data-num="76"></td><td><pre>                    trail <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>                </pre></td></tr><tr><td data-num="78"></td><td><pre>                t <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="81"></td><td><pre></pre></td></tr><tr><td data-num="82"></td><td><pre>           <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="85"></td><td><pre>            <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre>            <span class="token comment">// 释放锁</span></pre></td></tr><tr><td data-num="87"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">release</span><span class="token punctuation">(</span>savedState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="88"></td><td><pre>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="89"></td><td><pre>                <span class="token keyword">return</span> savedState<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="90"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="91"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="94"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="95"></td><td><pre>                node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="96"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="97"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="98"></td><td><pre></pre></td></tr><tr><td data-num="99"></td><td><pre>        <span class="token comment">// 是否在阻塞队列</span></pre></td></tr><tr><td data-num="100"></td><td><pre>     <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="101"></td><td><pre></pre></td></tr><tr><td data-num="102"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>waitStatus <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION <span class="token operator">||</span> node<span class="token punctuation">.</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="103"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="104"></td><td><pre>            <span class="token comment">// 如果有后继节点，一定是在阻塞队列</span></pre></td></tr><tr><td data-num="105"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// If has successor, it must be on queue</span></pre></td></tr><tr><td data-num="106"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="107"></td><td><pre>        <span class="token comment">// 看看节点是否处于阻塞队列中</span></pre></td></tr><tr><td data-num="108"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="109"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="110"></td><td><pre>    <span class="token comment">// 从后往前找节点</span></pre></td></tr><tr><td data-num="111"></td><td><pre>       <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="112"></td><td><pre>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="113"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="114"></td><td><pre>            <span class="token comment">// 如果找到 node, 直接返回 true</span></pre></td></tr><tr><td data-num="115"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> node<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="116"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="117"></td><td><pre>                <span class="token comment">// 如果尾部为 null, 直接返回 fasle</span></pre></td></tr><tr><td data-num="118"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="119"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="120"></td><td><pre>            t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="121"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="122"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>await 方法还是比较复杂的，整体流程如下:</p><ol><li>检查线程中断标志，如果被中断，直接抛异常</li><li>将节点添加到阻塞队列中</li><li>释放当前节点线程持有的锁，并保存一下锁状态</li><li>判断是否还在阻塞队列中，如果不在阻塞队列中，直接阻塞</li><li>被 singal 唤醒后，就用之前保存的锁状态去尝试获取锁</li></ol><p>接下来看看 signal</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token comment">// 只有持有锁，才有使用 signal</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token class-name">Node</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 从等待队列的第一个节点开始唤醒</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 从等待队列头结点开始，知道唤醒一个为止</span></pre></td></tr><tr><td data-num="11"></td><td><pre>         <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 如果等待队列中只有一个节点，将队列首节点和尾节点指针置 NULL</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                     <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 如果不能改变 WaitStatus 状态，则说明节点被取消，直接返回 false。</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">/*</pre></td></tr><tr><td data-num="27"></td><td><pre>         * Splice onto queue and try to set waitStatus of predecessor to</pre></td></tr><tr><td data-num="28"></td><td><pre>         * indicate that thread is (probably) waiting. If cancelled or</pre></td></tr><tr><td data-num="29"></td><td><pre>         * attempt to set waitStatus fails, wake up to resync (in which</pre></td></tr><tr><td data-num="30"></td><td><pre>         * case the waitStatus can be transiently and harmlessly wrong).</pre></td></tr><tr><td data-num="31"></td><td><pre>         */</span></pre></td></tr><tr><td data-num="32"></td><td><pre>         <span class="token comment">// 进行到这一步，使用 enq 将节点重新加入阻塞队列，获取 node 在 AQS 队列中前驱节点的状态</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token comment">// 如果 waitStatus 被取消或者不能替换成 SIGNAL, 就唤醒当前节点</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token comment">// 唤醒节点</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token comment">// 否则直接在阻塞队列里排队。</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>signal 方法还是比较容易理解的，其实就是从等待队列的第一个节点开始，进行唤醒，如果唤醒失败 (节点被取消), 就唤醒下一个。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p><strong>总的来说，AQS 还是比较复杂的，但是去看里面的源码，才会发现编程的魅力，DougLea 深厚的编码能力，代码写的十分优雅，以及其中的思想值得学习。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;reentrylock的继承链&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#reentrylock的继承链&quot;&gt;#&lt;/a&gt; ReentryLock 的继承链&lt;/h1&gt;
&lt;p&gt;&lt;img data-src=&quot;https://raw.githubuserconte</summary>
      
    
    
    
    <category term="后端" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/tags/Java/"/>
    
    <category term="锁" scheme="https://guyouwyh.github.io/guyouwyh/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>LongAdder源码分析</title>
    <link href="https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/LongAddr/"/>
    <id>https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/LongAddr/</id>
    <published>2022-11-01T11:58:40.398Z</published>
    <updated>2022-11-01T13:58:25.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="anchor" href="#介绍">#</a> 介绍</h1><p>LongAdder 的 JDK8 种提供的一个针对 Long 类型的原子操作。</p><h1 id="核心原理"><a class="anchor" href="#核心原理">#</a> 核心原理</h1><p>先说一下为什么要出现这么类？明明有 AtomicLong, 但是实际上，AtomicLong 在高并发下可能会出现大量线程 CAS 失败，造成自旋，消耗 cpu 性能。原因归咎于锁的粒度太大了，LongAdder 使用了一种空间换时间的思想:<ins> 将一个变量拆成多个变量。把一个 Long 类型拆成一个 base 变量外加多个 Cell。当多个线程并发累加的时候，如果并发度低，就直接加到 base 变量上，如果并发度高，就平摊在 Cell 上。最后取值的时候再将 base 和 Cell 求 sum 运算。</ins>, 这样的话，就减少了内部竞争粒度，分散了热点，也就是减少了 CAS 失败率，提高了性能。</p><p><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221101201303.png" alt="" /></p><h1 id="cell和base"><a class="anchor" href="#cell和base">#</a> Cell 和 Base</h1><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> cells<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">long</span> sum <span class="token operator">=</span> base<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                    sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这是 LongAdder 中的求和函数，可以看到直接拿到 Cell 数组的值，然后一个个累加起来，最后返回。<br />Cell 其实是 LongAdder 父类 Strip64 中的一个内部类，源码如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@sun.misc.Contended</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Cell</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Cell</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> value <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">cas</span><span class="token punctuation">(</span><span class="token keyword">long</span> cmp<span class="token punctuation">,</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// Unsafe mechanics</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> UNSAFE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                UNSAFE <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> ak <span class="token operator">=</span> <span class="token class-name">Cell</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                valueOffset <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span>objectFieldOffset</pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token punctuation">(</span>ak<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码应该很熟悉了，还是使用了 Unsafe 种的 CAS 操作。<br />可以注意到在 Sum 求和函数中，并没有给 cell [] 数组加锁，试想一个场景，如果一边有线程对其执行求和操作，一边还有线程修改数组里的值，那么会怎么样？这里牵扯到一个思想，叫做<span class="red">最终一致性</span>，也就是说不要求强一致性，只要最后的 sum 成功即可。</p><h1 id="伪共享与缓存行填充"><a class="anchor" href="#伪共享与缓存行填充">#</a> 伪共享与缓存行填充</h1><p>可以注意到 Cell 内部类前有一个注解修饰 <code>@sun.misc.Contended</code> 。有没有好奇这个注解有什么用？其实这个注解解决了伪共享问题。<br />在 cpu 架构中，cpu 是通过缓存与主存进行数据交换的，而交换的最小单位被称为缓存行 (Cache line), 在 64 位 x86 架构中，缓存行的大小是 64byte, 也就是 8 个 long 类型大小。<br />假设一个两核的 cpu, 主存中有 X、Y 变量，而 X、Y 变量同样也在两个 cpu 中的缓存行中，并且 X 和 Y 都处于同一个缓存行中。假如 cpu1 修改了 X 变量，那么就会通过总线通知 cpu2 对应的缓存行失效，但是实际上，Y 并没有改变，但是 Y 也失效了。<br />本来只应该让 X 失效，却让 Y 也失效了，也就是 cpu 缓存伪共享问题。<br />解决方案其实很简单，让 X 和 Y 不在同一个缓存行就可以了，X 所在的缓存行失效并不会影响 Y 所在的缓存行失效。<br />这时候就需要缓存行填充，即在 X、Y 后加上 7 个 long 类型，让 X 和 Y 处于不同的缓存行中。<br /><span class="red"> <code>@sun.misc.Contended</code>  正是这个作用，用于缓存行填充，从而保证 Cell 数组中相邻的元素不会落到同一个缓存行中</span>。</p><h1 id="longadder源码解析"><a class="anchor" href="#longadder源码解析">#</a> LongAdder 源码解析</h1><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 自增调用 add</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 自减也调用 add</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">decrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 如果 cells 不为空 或者将 x 添加到 base 上失败</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">casBase</span><span class="token punctuation">(</span>b <span class="token operator">=</span> base<span class="token punctuation">,</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            </pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">//getProbe 可以理解为一个随机数，相当于随机找一个 cell</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token comment">// 这里说明该数组位置已经初始化，但是 CAS 失败，存在争用</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token comment">// 能走到这，说明 cell 没有初始化，那么就进行初始化</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token function">longAccumulate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token comment">//BASE 其实就是 base 变量在内存中的偏移量</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">casBase</span><span class="token punctuation">(</span><span class="token keyword">long</span> cmp<span class="token punctuation">,</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASE<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里的操作还是很简单的，就是首先判断能不能将 x 添加到 base 上，如果不能加到 base 上，先判断下 cells 有没有被初始化，如果被初始化了，就使用一个 getProbe () 函数随机数，这个函数对于同一个线程来说，值是一样的，也就是相当于将同一个线程绑定到了一个固定的 Cell 下标上，由于 cell 的长度一定是 2 的整数幂，因此 &amp; 相当于 %, 可以理解为哈希定位数组，如果定位的下标没有被初始化，那么久要执行 longAccumulate 了。</p><p>下面来看看 longAccumulate:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">longAccumulate</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token class-name">LongBinaryOperator</span> fn<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                              <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">//h 可以理解做哈希值</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">int</span> h<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// force initialization</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">//wasUncontented 为 false 的话，表示已经被初始化了</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// True if last slot nonempty</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token class-name">Cell</span> a<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 判断下 cells 是不是完全没有初始化？</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token comment">// 如果不是完全没有初始化，就用 h 哈希一下定位数组下标</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token comment">// 如果定位的数组下标为 null</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// Try to attach new Cell</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                         <span class="token comment">// 尝试直接初始化一个 Cell</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                        <span class="token class-name">Cell</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Optimistically create</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                        <span class="token comment">// 这里是为了防止重复初始化</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                        <span class="token comment">// 试想一下如果多个线程同时进入到这，那么只有当 cellsBusy 为 0, 并且 CAS 成功才能真正进行初始化</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                            <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// Recheck under lock</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                                <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                                    <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                                    rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                                    rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                                    created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                                <span class="token comment">// 这里初始化成功，将 cellsBusy 恢复</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                            <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// 能进进入到这里的，肯定是 cas 失败，说明别的线程已经抢在他前面进行初始化了，直接进入下一轮循环</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                    <span class="token comment">//collide 表示扩容意向，走到这说明不需要扩容</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>               <span class="token comment">// 如果 wasUncontented 为 false, 就说明发生了竞争，需要进入下轮循环，重新获取计算 Probe 值</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span>       <span class="token comment">// CAS already known to fail</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                    wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token comment">// Continue after rehash</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                </pre></td></tr><tr><td data-num="50"></td><td><pre>                <span class="token comment">// 当前 rehash 过哈希值，CAS 更新 Cell</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span></pre></td></tr><tr><td data-num="52"></td><td><pre>                                             fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>                    <span class="token comment">// 达到最大值，或者当前的 as 过期</span></pre></td></tr><tr><td data-num="55"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> NCPU <span class="token operator">||</span> cells <span class="token operator">!=</span> as<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="56"></td><td><pre>                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">// At max size or stale</span></pre></td></tr><tr><td data-num="57"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre>                <span class="token comment">// 设置扩容意向为 true, 但不一定真的发生扩容</span></pre></td></tr><tr><td data-num="59"></td><td><pre>                    collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>                    <span class="token comment">// 真正的扩容逻辑</span></pre></td></tr><tr><td data-num="61"></td><td><pre>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// Expand table unless </span></pre></td></tr><tr><td data-num="64"></td><td><pre>                        <span class="token comment">//2 倍扩容</span></pre></td></tr><tr><td data-num="65"></td><td><pre>                            <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>                            <span class="token comment">// 迁移原数组</span></pre></td></tr><tr><td data-num="67"></td><td><pre>                            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="68"></td><td><pre>                                rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>                            cells <span class="token operator">=</span> rs<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>                        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>                    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>                        cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>                    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment">// Retry with expanded </span></pre></td></tr><tr><td data-num="76"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>                <span class="token comment">// 重设哈希值</span></pre></td></tr><tr><td data-num="78"></td><td><pre>                h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre>            <span class="token comment">// 进入到这里的，说明数组没有初始化，这里尝试去初始化整个数组</span></pre></td></tr><tr><td data-num="81"></td><td><pre>            <span class="token comment">// 依旧是要 CAS 成功才能进去初始化，这里还是用了 cells==as, 即保证数组未初始化</span></pre></td></tr><tr><td data-num="82"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>                <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="85"></td><td><pre>                    <span class="token comment">//  又来一波判断，确认数组 as 是不是为 null</span></pre></td></tr><tr><td data-num="86"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="87"></td><td><pre>                        <span class="token comment">// 初始为为 2</span></pre></td></tr><tr><td data-num="88"></td><td><pre>                        <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="89"></td><td><pre>                        <span class="token comment">// 将 0 或者 1 初始化为 x 值</span></pre></td></tr><tr><td data-num="90"></td><td><pre>                        rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="91"></td><td><pre>                        cells <span class="token operator">=</span> rs<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>                        init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="94"></td><td><pre>                <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="95"></td><td><pre>                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="96"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="97"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="98"></td><td><pre>                <span class="token comment">// 如果初始化完成，直接跳出循环</span></pre></td></tr><tr><td data-num="99"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="100"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="101"></td><td><pre>            <span class="token comment">// 进入到这里的，说明有个线程正在初始化整个数组，因此，尝试加到 base 上，如果成功就直接 break, 否则继续下次循环</span></pre></td></tr><tr><td data-num="102"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casBase</span><span class="token punctuation">(</span>v <span class="token operator">=</span> base<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span></pre></td></tr><tr><td data-num="103"></td><td><pre>                                        fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="104"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span>                          <span class="token comment">// Fall back on using base</span></pre></td></tr><tr><td data-num="105"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="106"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里有一个 for 循环，有三个分支:</p><ul><li>第一个分支，说明整个数组已经初始化，接下来其实又有几个小分支<ul><li>如果哈希定位到的数组下标没有初始化，则尝试 CAS 初始化</li><li>如果定位到的数组下标初始化了，尝试 CAS 添加</li></ul></li><li>第二个分支，说明整个数组都没有被初始化，此时需要初始化整个数组。</li><li>第三个分支，说明有其他线程正在第二个分支初始化，继续尝试能不能加到 base 上，如果不能则继续循环进入到第一个分支。</li></ul><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p><strong>LongAdder 中，有一个计组知识，即缓存伪共享和缓存行填充，jdk8 中提供了一个 Contented 注解就是先了缓存行填充，LongAddr 的思想有一种拆分的思想，其中不仅大量运用了 CAS, 并且还有一些小的优化，比如容量是 2 的整数幂可以使用 &amp; 代替 %, 加快运算。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#介绍&quot;&gt;#&lt;/a&gt; 介绍&lt;/h1&gt;
&lt;p&gt;LongAdder 的 JDK8 种提供的一个针对 Long 类型的原子操作。&lt;/p&gt;
&lt;h1 id=&quot;核心原理&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="后端" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Atomic原子类源码解析</title>
    <link href="https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2022-11-01T09:19:19.501Z</published>
    <updated>2022-11-01T11:58:32.577Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在解析 Atomic 源码之前，先要介绍一些前置知识，比如 CAS、Java 的 Unsafe 类等</strong></p><h1 id="cas"><a class="anchor" href="#cas">#</a> CAS</h1><p>相信乐观锁都听说过，那么乐观锁是什么呢？<br /> 乐观锁可以理解为，在线程操作共享变量的时候，读操作并不会加锁，到要进行写操作的时候才会 &quot;加锁&quot;, 这个加锁其实就是 CAS。<br />CAS (Compare And Swap), 从字面意思来解释，就是先比较和交换，通俗来说，就是我要改变的变量原来是什么样子的？如果原来的样子跟我所说的符合，那么就允许修改，如果跟我所说的不符合，修改失败。<br />当然，比较重要的一点是，Compare And Swap, 必须是原子操作，即比较和交换，要么同时执行成功，要么同时失败，操作不可再分隔。</p><p>那么在 Java 中乐观锁是怎么样应用的？或者说怎么实现乐观锁，在 concurrent 并发包中，提供了 Atomic 类，都是基于 CAS 操作进行的。</p><p><strong>下面说说 CAS 的优点:</strong></p><h2 id="cas优点"><a class="anchor" href="#cas优点">#</a> CAS 优点</h2><p>CAS 相当于无锁编程，如果是在 intel 处理器中，底层使用了原语指令 cmpxchg 实现了 CAS, 这样在少量线程并发操作中，性能会比加锁好。</p><h2 id="cas的可能会产生的问题"><a class="anchor" href="#cas的可能会产生的问题">#</a> CAS 的可能会产生的问题</h2><ol><li><p><mark>ABA 问题</mark><br />所谓的 ABA 问题，比如说两个线程 A 和 B,A 使用 CAS 修改了变量，然后 B 又使用 CAS 将值修改回去了，那么其实我们是感知不到变量被修改，也就是说只通过值的比较，就会造成 ABA 问题。<br /><mark>解决办法是使用加一个版本号，每次修改既要比较值也要比较版本号，每次修改版本号都会递增。</mark></p></li><li><p><mark>循环时间长导致开销大</mark><br />一般使用 CAS, 都会在一个循环中，一直重试，直到成功，那么如果一直重试，会导致 CPU 开销很大。<br /><mark>解决办法是限定自旋次数，也就是循环的次数，当循环到一定次数还没成功，就直接跳出。</mark></p></li><li><p><mark>只能保证一个变量的原子操作</mark><br />如果我们要替换的是一个对象，那么 CAS 可能无法完成，因为它只能保证一个变量的原子操作，在 Java 中提供了对一个对象的 CAS 操作。</p></li></ol><h1 id="unsafe类"><a class="anchor" href="#unsafe类">#</a> Unsafe 类</h1><p>Unsafe 这个类，提供了对操作系统内存管理等一些操作的接口，因此这个类非常危险，所以叫 Unsafe。<br />下面先看一下它的构造器:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span>Reflection</span><span class="token punctuation">.</span><span class="token function">registerMethodsToFilter</span><span class="token punctuation">(</span><span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"getUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">private</span> <span class="token class-name">Unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> theUnsafe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，它的构造器是私有的，因此不能直接初始化这个类，可以通过反射获取这个类的 theUnsafe 变量。从而获取这个类。<br />关注这个类里面以 <code>compareAndSwap</code>  开头的方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                                                     <span class="token class-name">Object</span> expected<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                                                     <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                                                  <span class="token keyword">int</span> expected<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                                                  <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre> </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                                                   <span class="token keyword">long</span> expected<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                                                   <span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以看到只提供了 Object、int、long 的方法。<br />这些方法都是本地方法，方法里有 4 个参数:</p><ol><li>要进行 CAS 的对象或者变量</li><li>要操作的对象或者变量在内存中的偏移量</li><li>期待更新的值</li><li>要替换的值</li></ol><p>那么有个问题，这个 offset 偏移量，怎么知道是多少呢？<br />Unsafe 类中也提供了一个本地方法帮助我们计算字段的偏移量</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">objectFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">Field</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>只要我们通过反射拿到 Field 对象，就能获取到字段的偏移量。</p><h1 id="atomicinteger类"><a class="anchor" href="#atomicinteger类">#</a> AtomicInteger 类</h1><p>先看一下 AtomicInteger 类的源码:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">6214790243416807050L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token comment">// 这里获取了 Unsafe 对象</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 字段偏移量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 静态代码块初始化 valueOffset</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token comment">// 可以看到，就是调用了 unsafe 类中的 objectFieldOffset 计算字段的偏移量</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span>objectFieldOffset</pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// 这个 value 就是我们传入的变量</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 有参构造</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre> </pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre>   </pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        unsafe<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre> </pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre></pre></td></tr><tr><td data-num="52"></td><td><pre>   </pre></td></tr><tr><td data-num="53"></td><td><pre></pre></td></tr><tr><td data-num="54"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="57"></td><td><pre></pre></td></tr><tr><td data-num="58"></td><td><pre></pre></td></tr><tr><td data-num="59"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="61"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="62"></td><td><pre></pre></td></tr><tr><td data-num="63"></td><td><pre>   </pre></td></tr><tr><td data-num="64"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="67"></td><td><pre></pre></td></tr><tr><td data-num="68"></td><td><pre>   </pre></td></tr><tr><td data-num="69"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="71"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="72"></td><td><pre></pre></td></tr><tr><td data-num="73"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="75"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="76"></td><td><pre></pre></td></tr><tr><td data-num="77"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="78"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span> <span class="token operator">+</span> delta<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre></pre></td></tr><tr><td data-num="81"></td><td><pre></pre></td></tr><tr><td data-num="82"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="85"></td><td><pre></pre></td></tr><tr><td data-num="86"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="87"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="88"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="89"></td><td><pre></pre></td></tr><tr><td data-num="90"></td><td><pre></pre></td></tr><tr><td data-num="91"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="94"></td><td><pre></pre></td></tr><tr><td data-num="95"></td><td><pre></pre></td></tr><tr><td data-num="96"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">floatValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="97"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="98"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="99"></td><td><pre></pre></td></tr><tr><td data-num="100"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="101"></td><td><pre>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="102"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="103"></td><td><pre></pre></td></tr><tr><td data-num="104"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>AtomicInteger 类比较简单，其实就是在内部聚合了一个 Unsafe 对象，以及一个 value 存储值，valueoffset 存储 value 在内存中的偏移量。在类初始化的时候，在静态代码块中通过 unsafe 获取到 valueoffset 的值并保存，然后之后的所有操作其实都是使用 unsafe 类中的本地方法进行的。</p><p>剩下的 AtomicLong、AtomicBoolean、AtomicObject 也是一样的，都是使用 unsafe 类中的本地方法。需要注意的是 AtomicBoolean 其实是使用 Unsafe.compareAndSwapInt 方法进行 CAS 操作的。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        value <span class="token operator">=</span> initialValue <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">return</span> value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> expect<span class="token punctuation">,</span> <span class="token keyword">boolean</span> update<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">int</span> e <span class="token operator">=</span> expect <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">int</span> u <span class="token operator">=</span> update <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> e<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h1 id="atomicstampedreference和atomicmarkablereference"><a class="anchor" href="#atomicstampedreference和atomicmarkablereference">#</a> AtomicStampedReference 和 AtomicMarkableReference</h1><p>这两个类 CAS 比较的时候，不仅仅是比较值，还比较版本号，解决了 CAS 产生的 ABA 问题。</p><p>AtomicStrampedReference 源码如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicStampedReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 创建了一个内部类 Pair</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>         <span class="token comment">// 引用</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">final</span> <span class="token class-name">T</span> reference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 版本号</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">int</span> stamp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">private</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">T</span> reference<span class="token punctuation">,</span> <span class="token keyword">int</span> stamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>reference <span class="token operator">=</span> reference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>stamp <span class="token operator">=</span> stamp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">T</span> reference<span class="token punctuation">,</span> <span class="token keyword">int</span> stamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>reference<span class="token punctuation">,</span> stamp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> pair<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token comment">// 在构造函数中，直接将对象和初始版本号包装成 Pair</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">AtomicStampedReference</span><span class="token punctuation">(</span><span class="token class-name">V</span> initialRef<span class="token punctuation">,</span> <span class="token keyword">int</span> initialStamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        pair <span class="token operator">=</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>initialRef<span class="token punctuation">,</span> initialStamp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">return</span> pair<span class="token punctuation">.</span>reference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> pair<span class="token punctuation">.</span>stamp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stampHolder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> pair <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pair<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        stampHolder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pair<span class="token punctuation">.</span>stamp<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">return</span> pair<span class="token punctuation">.</span>reference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>    </pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre>  <span class="token comment">//CAS 操作，四个参数，两个两个一对</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token class-name">V</span>   expectedReference<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                                 <span class="token class-name">V</span>   newReference<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                                 <span class="token keyword">int</span> expectedStamp<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                                 <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token comment">// 获取构造函数初始化时候包装的 Pair 对象                        </span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> current <span class="token operator">=</span> pair<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token keyword">return</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token comment">// 比较期待的值是否一致</span></pre></td></tr><tr><td data-num="51"></td><td><pre>            expectedReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>            expectedStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>            <span class="token comment">// 如果要修改的值和版本号与原来的一样，直接返回 true</span></pre></td></tr><tr><td data-num="54"></td><td><pre>            <span class="token punctuation">(</span><span class="token punctuation">(</span>newReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>              newStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp<span class="token punctuation">)</span> <span class="token operator">||</span></pre></td></tr><tr><td data-num="56"></td><td><pre>              <span class="token comment">// 如果是修改新值，那么进入 casPair 中</span></pre></td></tr><tr><td data-num="57"></td><td><pre>             <span class="token function">casPair</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>newReference<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="59"></td><td><pre></pre></td></tr><tr><td data-num="60"></td><td><pre>    </pre></td></tr><tr><td data-num="61"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">V</span> newReference<span class="token punctuation">,</span> <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>        <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> current <span class="token operator">=</span> pair<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newReference <span class="token operator">!=</span> current<span class="token punctuation">.</span>reference <span class="token operator">||</span> newStamp <span class="token operator">!=</span> current<span class="token punctuation">.</span>stamp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="64"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>pair <span class="token operator">=</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>newReference<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="65"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="66"></td><td><pre></pre></td></tr><tr><td data-num="67"></td><td><pre></pre></td></tr><tr><td data-num="68"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">attemptStamp</span><span class="token punctuation">(</span><span class="token class-name">V</span> expectedReference<span class="token punctuation">,</span> <span class="token keyword">int</span> newStamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="69"></td><td><pre>        <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> current <span class="token operator">=</span> pair<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>        <span class="token keyword">return</span></pre></td></tr><tr><td data-num="71"></td><td><pre>            expectedReference <span class="token operator">==</span> current<span class="token punctuation">.</span>reference <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>            <span class="token punctuation">(</span>newStamp <span class="token operator">==</span> current<span class="token punctuation">.</span>stamp <span class="token operator">||</span></pre></td></tr><tr><td data-num="73"></td><td><pre>             <span class="token function">casPair</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> <span class="token class-name">Pair</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>expectedReference<span class="token punctuation">,</span> newStamp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="75"></td><td><pre></pre></td></tr><tr><td data-num="76"></td><td><pre></pre></td></tr><tr><td data-num="77"></td><td><pre></pre></td></tr><tr><td data-num="78"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> UNSAFE <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>     <span class="token comment">// 直接获取 pair 的偏移量</span></pre></td></tr><tr><td data-num="80"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> pairOffset <span class="token operator">=</span></pre></td></tr><tr><td data-num="81"></td><td><pre>        <span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>UNSAFE<span class="token punctuation">,</span> <span class="token string">"pair"</span><span class="token punctuation">,</span> <span class="token class-name">AtomicStampedReference</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="82"></td><td><pre>   <span class="token comment">// 这里的关键来了，将新值和新版本号包装成 Pair 后，直接调用 Unsafe 的方法进行替换</span></pre></td></tr><tr><td data-num="83"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">casPair</span><span class="token punctuation">(</span><span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> cmp<span class="token punctuation">,</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> pairOffset<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="85"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="86"></td><td><pre></pre></td></tr><tr><td data-num="87"></td><td><pre><span class="token comment">// 计算偏移量，也是使用了 unsafe 的本地方法</span></pre></td></tr><tr><td data-num="88"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">objectFieldOffset</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> UNSAFE<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="89"></td><td><pre>                                  <span class="token class-name">String</span> field<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> klazz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="90"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="91"></td><td><pre>            <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>klazz<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>            <span class="token comment">// Convert Exception to corresponding Error</span></pre></td></tr><tr><td data-num="94"></td><td><pre>            <span class="token class-name">NoSuchFieldError</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchFieldError</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="95"></td><td><pre>            error<span class="token punctuation">.</span><span class="token function">initCause</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="96"></td><td><pre>            <span class="token keyword">throw</span> error<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="97"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="98"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="99"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>AtomicMarkableReference 源码分析:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicMarkableReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">final</span> <span class="token class-name">T</span> reference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> mark<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">private</span> <span class="token class-name">Pair</span><span class="token punctuation">(</span><span class="token class-name">T</span> reference<span class="token punctuation">,</span> <span class="token keyword">boolean</span> mark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>reference <span class="token operator">=</span> reference<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>mark <span class="token operator">=</span> mark<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">T</span> reference<span class="token punctuation">,</span> <span class="token keyword">boolean</span> mark<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pair</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>reference<span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>AtomicMarkableReference 和 AtomicStampedReference 的区别只是 stamp 类型的区别，前者是 boolean, 后者是 int, 仅此而已。</p><h1 id="atomicintegerfieldupdater"><a class="anchor" href="#atomicintegerfieldupdater">#</a> AtomicIntegerFieldUpdater</h1><p>字面意思可以理解为，原子字段更新器，这个类的出现是为了去对已经存在的类中的变量进行原子操作。<br />源码解析:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">protected</span> <span class="token class-name">AtomicIntegerFieldUpdater</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>先看构造方法，使用了权限修饰符 protected 进行修饰，也就是说明不能直接初始化对象，那么该类一定提供了一个静态方法来让我们获得这个对象。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@CallerSensitive</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> <span class="token class-name">AtomicIntegerFieldUpdater</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> <span class="token function">newUpdater</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span> tclass<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                                                              <span class="token class-name">String</span> fieldName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AtomicIntegerFieldUpdaterImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token punctuation">(</span>tclass<span class="token punctuation">,</span> fieldName<span class="token punctuation">,</span> <span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，又 new 了一个实现类，先看参数，第一个是类的 class 对象，第二个的字段名。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">AtomicIntegerFieldUpdaterImpl</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> tclass<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                                      <span class="token keyword">final</span> <span class="token class-name">String</span> fieldName<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                                      <span class="token keyword">final</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> caller<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Field</span> field<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">final</span> <span class="token keyword">int</span> modifiers<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                field <span class="token operator">=</span> <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                    <span class="token keyword">new</span> <span class="token class-name">PrivilegedExceptionAction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Field</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                        <span class="token keyword">public</span> <span class="token class-name">Field</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchFieldException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                            <span class="token keyword">return</span> tclass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>                modifiers <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>ReflectUtil</span><span class="token punctuation">.</span><span class="token function">ensureMemberAccess</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    caller<span class="token punctuation">,</span> tclass<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token class-name">ClassLoader</span> cl <span class="token operator">=</span> tclass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token class-name">ClassLoader</span> ccl <span class="token operator">=</span> caller<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ccl <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>ccl <span class="token operator">!=</span> cl<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>cl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">isAncestor</span><span class="token punctuation">(</span>cl<span class="token punctuation">,</span> ccl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>ReflectUtil</span><span class="token punctuation">.</span><span class="token function">checkPackageAccess</span><span class="token punctuation">(</span>tclass<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PrivilegedActionException</span> pae<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>pae<span class="token punctuation">.</span><span class="token function">getException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token comment">// 字段必须是 int 类型</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Must be integer type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>       <span class="token comment">// 修饰符必须是 volatile</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isVolatile</span><span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Must be volatile type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>      </pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>cclass <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isProtected</span><span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                           tclass<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>caller<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                           <span class="token operator">!</span><span class="token function">isSamePackage</span><span class="token punctuation">(</span>tclass<span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                          <span class="token operator">?</span> caller <span class="token operator">:</span> tclass<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>tclass <span class="token operator">=</span> tclass<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> <span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从源码中可以知道，这个类做了一些限制条件，比如更新必须是 int 类型变量，修饰符必须有 volatile, 除了这些限制条件外，基本原理与 AtomicInteger 一样。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>对于 Atomic 原子类来说，底层的原理其实很好理解，就是调用了 Unsafe 中的本地方法，实现 CAS。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;在解析 Atomic 源码之前，先要介绍一些前置知识，比如 CAS、Java 的 Unsafe 类等&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;cas&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#cas&quot;&gt;#&lt;/a&gt; CAS&lt;/h1&gt;
&lt;p&gt;相信乐观</summary>
      
    
    
    
    <category term="后端" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JMM和volatile的一些理解</title>
    <link href="https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/JMM%E5%92%8Cvolatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/JMM%E5%92%8Cvolatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2022-11-01T04:10:48.805Z</published>
    <updated>2022-11-01T09:15:50.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jmm是什么"><a class="anchor" href="#jmm是什么">#</a> JMM 是什么？</h1><p>对于学 Java 多线程的人来说，一定听说过 JMM, 那么 JMM 到底是什么呢？JMM 全称 (<ins>Java Memory Model</ins>) 即 Java 内存模型。它是 Java 的一套规范，对上，是 JVM 和开发者之间的约定，对下，是 JVM 和编译器、CPU 之间的约定。</p><h1 id="jmm是作用是什么"><a class="anchor" href="#jmm是作用是什么">#</a> JMM 是作用是什么？</h1><p>JMM 是作用主要是明确在多线程环境下，什么时候需要重排序，什么时候不需要重排序。为了更好的了解 JMM, 先介绍一下内存的可见性问题和重排序问题。</p><h1 id="内存可见性问题"><a class="anchor" href="#内存可见性问题">#</a> 内存可见性问题</h1><p>首先来说说，为什么会存在内存可见性问题？举个栗子，假设是一个 2 核 CPU, 在 x86 架构下它的缓存布局如下:<br /><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221101160705.png" alt="" /><br />CPU 有 3 级缓存，因为存在 CPU 缓存一致性协议 MESI, 多个 CPU 缓存不会出现不同步问题，因此不会有不可见问题。<br />但是还有个问题就是：使用缓存一致性协议，会对性能有很大的损耗，因此 CPU 的设计者们又进行了优化，比如在 CPU 计算单元与 L1 缓存之间又加上了 LoadBuufer 和 StoreBuffer。<br />L1、L2、L3 缓存与主存之间，由于有缓存一致性协议的缘故，是同步的，但是 L1 和 StoreBuffer 和 LoadBuffer 之间并不是同步的，通俗来说 ++&quot;往内存中写入一个变量，这个变量会先被写入到 StoreBuffer 中，稍后异步写入 L1 缓存中，同时同步写入主内存中&quot;++。<br />基于这个原因，如果我们在引入 StoreBuffer 之后，CPU 读取变量时，直接从缓存中读取，则可能出现 StoreBuffer 中存在已经修改的变量，但是还未同步到缓存中，因此 CPU 会先从 StoreBuffer 中读取，这样保证了单 CPU 顺序执行指令过程的可见性。 这种机制也被称为 Store Fowarding。</p><p>但是，如果我们站在操作系统内核的角度下看 CPU 缓存模型是这样的:<br /><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221101162224.png" alt="" /></p><p>然后 JVM 就将这种模型抽象成了 JMM 模型:<br /><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221101162419.png" alt="" /></p><h1 id="重排序"><a class="anchor" href="#重排序">#</a> 重排序</h1><p>重排序由三个分类:</p><ul><li>编译器重排序：对于没有先后以来关系的语句，编译器可以重新调整语句的执行顺序</li><li>CPU 指令重排序：在指令级别，让没有以来关系的多条指令并行</li><li>CPU 内存重排序: CPU 有自己的缓存，执行的执行顺序和写入主内存的顺序不完全一致<br />一般而言，第三类就是造成内存可见性的主要原因。<br />举个例子，如果有两个线程 A 和 B。有一个全局变量 X=0, 如果线程 A 先修改了 X=1, 但是此时，由于要先写入 StoreBuffer, 此时并没有刷新到主内存，主内存中的 X 还是等于 0, 此时线程 B 看到的 X 还是 0。<br />将这种重排序称为内存重排序，会造成内存可见性问题。</li></ul><p>如果站在开发者的角度来看，肯定是希望不要有任何重排序，这样写内存的顺序也会跟代码顺序一样。<br />但是，如果站在 CPU 的角度来看，会尽可能的进行重排序，提升运行效率。<br />这时候就产生了一个问题，重排序要有什么原则？要在什么场景下进行重排序？又或者说在什么场景下不能重排序？这相当于是对于开发者和 CPU 之间的一个约定。</p><h2 id="单线程程序的重排序规则"><a class="anchor" href="#单线程程序的重排序规则">#</a> 单线程程序的重排序规则</h2><p>对于单线程程序来说，只要没有产生数据依赖性，也就是操作 B 不依赖于操作 A, 那么 CPU 就可以任意重排序，因为最终产生的结果并不会改变。从开发者的角度来看，这样代码从头执行到尾，这就是 as-if-serial 语义，编译器可和 CPU 或许因为运行效率而做了重排序，但是，开发者感知不到，这样就不会产生内存可见性原因.</p><h2 id="多线程重排序规则"><a class="anchor" href="#多线程重排序规则">#</a> 多线程重排序规则</h2><p>对于多线程来说，编译器和 CPU 只能保证单个线程的 as-if-serial 语义，但是，如果多个线程操作了共享变量，对于这种影响，编译期和 CPU 并不会考虑，也就产生了可见性的问题。那么为了解决在多线程的情况下的重排序问题，也就衍生出来了另外一种规则 ----<span class="rainbow">happen-before</span></p><p>首先介绍为什么会有 happen-before。<br />为了明确定义在多线程场景下，什么时候可以重排序，什么时候不能重排序，Java 引入了 JMM, 这只是一套规范，但是，如何去描述这个规范呢？JMM 就引入了 happen-before, 使用 happen-before 去描述这两个操作之间的内存可见性。</p><p>那么 happen-before 究竟是什么呢？<br />顾名思义，happen-before 也就是发生在什么之前，如果 A happen-before B, 那么 B 应该清楚的知道 A 的所作所为，即 A 的执行结果必须对 B 可见，保证了跨线程的内存可见性。<br />然而，happen-before 并不代表 A 一定在 B 之前执行，但是如果 A 在 B 之前执行，那么 A 的结果一定对 B 可见，也就是定义了内存可见性的约束。<br />JMM 对开发者做出了一系列承诺:</p><ol><li>单线程中的每个操作，happen-before 对应线程中任意后续操作，即 as-if-serial 语义保证</li><li>对 volatile 变量的写入，happen-before 对应后续对这个变量的读取</li><li>对 synchronized 的解锁，happen-before 对应后续对这个锁的加锁。</li><li>如果 A happen-before B, B happen-before C , 那么 A happen-before C (即具有传递性)</li></ol><p>这样也就保证了内存的可见性，但是，在操作系统底层是怎么保证的呢？这就要说说内存屏障了。</p><h1 id="内存屏障"><a class="anchor" href="#内存屏障">#</a> 内存屏障</h1><p>为了禁止编译器重排序和 CPU 重排序，在编译器和 CPU 层面都有对应的指令，也就是内存屏障 (Memory Barrier). 这也正是 JMM 和 happen-before 规则的底层实现原理。</p><p>编译器的内存屏障，只是为了告诉编译器不要对指令进行重排序。CPU 并不会感知编译器中内存屏障的存在</p><p>而 CPU 的内存屏障是 CPU 提供的，可以由开发者显式调用。</p><h2 id="cpu中的内存屏障"><a class="anchor" href="#cpu中的内存屏障">#</a> CPU 中的内存屏障</h2><p>在理论层面，可以把基本的 CPU 内存屏障分为 4 种:</p><ol><li>LoadLoad: 禁止读和读重排序</li><li>StoreStore: 禁止写和写的重排序</li><li>LoadStore: 禁止读和写的重排序</li><li>StoreLoad: 禁止写和读的重排序</li></ol><h2 id="jdk中的内存屏障"><a class="anchor" href="#jdk中的内存屏障">#</a> JDK 中的内存屏障</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> </pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以看到，在 Unsafe 类中，提供了三种内存屏障，这三种内存屏障与 CPU 内存屏障的对应关系如下:<br /><span class="blue">loadFench = LoadLoad+ LoadSotre</span></p><p><span class="blue">storeFench = StoreStore + LoadStore</span></p><p><span class="blue">FullFench  = loadFence + storeFench + StoreLoad</span></p><h2 id="内存屏障的应用-volatile"><a class="anchor" href="#内存屏障的应用-volatile">#</a> 内存屏障的应用 --volatile</h2><p>相信大家都知道 volatile 这个关键字。valtile 有如下作用:</p><ul><li><p><mark>解决 64 位的写入问题</mark><br /> JVM 的规范并没有要求 64 位的 long 或者 double 的写入是原子的。在 32 位的机器上，一个 64 位的变量写入可能被拆分成两个 32 位的写操作来执行。这样一来，读取的线程就可能读到一半的值。解决办法是在 long 前面加上 volatile 关键字。</p></li><li><p><mark>解决内存可见性问题</mark><br />使用 volatile 关键字修饰的变量，会立刻从本地内存中刷新到共享内存中，保证了内存的可见性。</p></li><li><p><mark>解决重排序问题</mark><br />在使用 DCL, 即双重检查锁的时候，变量需要声明为 volatle, 这里也是为了防止指令重排序。<br />当我们 new 一个对象的时候，其实会发生三个步骤:</p></li></ul><ol><li>在堆中开辟一段空间</li><li>在这段空间 (内存) 上初始化成员变量</li><li>将引用指向这段空间的地址</li></ol><p>如果将步骤 2 和步骤 3 重排序了，获取的对象将会是未初始化的对象。这就会造成一些很严重的问题。</p><p>事实上，volatile 关键字底层就是使用了内存屏障。<br /><strong>1. 在 volatile 写操作前面插入一个 StoreStore 屏障。保证 volatile 写操作不会和之前的写操作重排序<br /> 2. 在 volatile 写操作后插入一个 StoreLoad 屏障，保证 volatile 写操作不会和之后的读操作重排序<br /> 3. 在 volatile 读操作后面插入一个 LoadLoad 屏障和 LoadStore 屏障，保证 volatile 读操作不会和之后的读操作、写操作重排序</strong></p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p><strong>通俗来说，JMM 其实就是 Java 提供的一种内存模型，每个线程都有自己的本地缓存，所有线程都有一个共享内存，本地缓存中的变量相当于是共享内存中变量的一个副本，当我们修改一个变量的时候，事实上会直接修改本地缓存中的变量，并不会立即刷新到共享内存中，这样就导致了多个线程之间不可见问题。<br />如果站在我们开发者的角度来说，可以使用 synchronized、volatile、final 去解决重排序以及可见性问题。<br />但是如果站在 JVM 的角度来说，它其实是通过 JMM 的 happen-before 规则来解决的。<br />更深层次一点，站在 CPU 层面来说，主要是通过内存屏障来解决的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jmm是什么&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#jmm是什么&quot;&gt;#&lt;/a&gt; JMM 是什么？&lt;/h1&gt;
&lt;p&gt;对于学 Java 多线程的人来说，一定听说过 JMM, 那么 JMM 到底是什么呢？JMM 全称 (&lt;ins&gt;Java Memory M</summary>
      
    
    
    
    <category term="后端" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="https://guyouwyh.github.io/guyouwyh/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://guyouwyh.github.io/guyouwyh/tags/Java/"/>
    
  </entry>
  
</feed>
