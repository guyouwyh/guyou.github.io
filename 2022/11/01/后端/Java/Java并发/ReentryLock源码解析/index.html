<!-- build time:Thu Nov 03 2022 11:08:43 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/rss.xml"><link rel="alternate" type="application/atom+xml" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/atom.xml"><link rel="alternate" type="application/json" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Java,锁"><link rel="canonical" href="https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ReentryLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><title>ReentryLock源码分析 - Java并发 - Java - 后端 | GuYou = 努力走,走到灯火通明</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">ReentryLock源码分析</h1><div class="meta"><span class="item" title="创建时间：2022-11-01 21:09:30"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-11-01T21:09:30+08:00">2022-11-01</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>19k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>17 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">GuYou</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2021/12/15/NdVWt9mYHDG1SFs.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/7E2sYl8uZARyLqh.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/b3sx9vieEGjrnaB.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/GZxwX8Q7EHtjP3B.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/B735tDMiU2eZFjK.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/z4byuMFYqEKQS2O.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="item" rel="index" title="分类于 后端"><span itemprop="name">后端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%90%8E%E7%AB%AF/Java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/" itemprop="item" rel="index" title="分类于 Java并发"><span itemprop="name">Java并发</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ReentryLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="故犹"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="努力走,走到灯火通明"></span><div class="body md" itemprop="articleBody"><h1 id="reentrylock的继承链"><a class="anchor" href="#reentrylock的继承链">#</a> ReentryLock 的继承链</h1><p><img data-src="https://raw.githubusercontent.com/guyouwyh/picture/main/20221101211500.png" alt=""></p><p><ins>可以看到，ReentrantLock 实现了 Lock 接口，有一个抽象内部类 Sync, 其继承了 AbstractQueuedSynchronizer 同步器，并且抽象内部类也有两个实现，一个是 FairSync, 一个是 NonFairSync。</ins></p><p><strong>在分析 ReentrantLock 源码之前，先说一些关于锁的前置知识。</strong></p><h1 id="锁的可重入"><a class="anchor" href="#锁的可重入">#</a> 锁的可重入</h1><p>那么问题来了，什么是锁的可重入呢？<br>当我们获取到了一把锁，能不能再次获取这把锁，这就叫锁的可重入，显然，如果锁不能重入的话，那么很容易发生死锁。</p><h1 id="锁的设计思路"><a class="anchor" href="#锁的设计思路">#</a> 锁的设计思路</h1><p>如果要实现一个锁的功能，必须要思考一下几个核心要素:</p><ol><li>需要一个变量去标记锁的状态，当获取锁时，这个变量增加，当释放锁时，这个变量减少，由于可能会有多个线程对变量进行操作，所以必须使用 CAS.</li><li>需要记录当前持有锁的线程，如果不记录的话，无法实现锁重入</li><li>需要操作系统底层的一些操作对线程进行阻塞或者唤醒。</li><li>需要一个队列维护阻塞的线程，这个队列也必须是线程安全的。</li></ol><h1 id="公平锁和非公平锁的概念"><a class="anchor" href="#公平锁和非公平锁的概念">#</a> 公平锁和非公平锁的概念</h1><p>基于上述的锁的实现思路，现在来说明一下什么是公平锁，什么是非公平锁。</p><ul><li><p>公平锁：顾名思义，即抢锁是公平的，就好比我们去排队买奶茶，肯定要排队，只有前面一个人买完奶茶，我们才能去买。对应的在阻塞队列中，只有作为阻塞队列队首的元素才能去抢锁。</p></li><li><p>非公平锁：即抢锁是不公平的，同样是去买奶茶，有些素质低的人，在队首的人买完奶茶后，直接去插队买奶茶。对应在阻塞队列中，如果持有锁的线程释放了锁，阻塞队列中的所有线程都可以去抢锁。</p></li></ul><p>一些锁的基础概念介绍完了，接下来就开始进行 ReentrantLock 的源码分析了:</p><h1 id="lock接口"><a class="anchor" href="#lock接口">#</a> Lock 接口</h1><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 获取锁，获取不到会阻塞</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 获取锁的过程中可以响应中断</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 尝试去获取锁，只会获取一次，即不会阻塞</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 在一定时间内获取不到所就返回</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 解锁</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 等待队列</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意一下带 try 的，try 开头的是尝试去获取锁，也就是只会获取一次。可以看到返回的 boolean 表示锁是否获取到。</p><p>在分析 ReentrantLock 之前，还需要说一下 AQS, 但是在说 AQS 之前，需要了解的一个前置知识是：CLH 自旋锁。</p><h1 id="clh锁"><a class="anchor" href="#clh锁">#</a> CLH 锁</h1><p>CLH 锁其实是一种基于队列 (具体为单向链表) 排队的自旋锁，是由 Craig、Landin 和 Hagersten 三人一起发明的，因此被命名为 CLH 锁，也叫 CLH 队列锁。</p><p>实现思路：申请加锁的过程首先会通过 CAS 操作在单向链表的尾部增加一个节点，之后该线程只需要在其前驱节点上进行普通自选，等待前驱节点释放锁即可，由于 CLH 锁只有在节点入队时进行一下 CAS 操作，在节点加入队列之后，抢锁线程不需要进行 CAS 自旋，只需要普通自旋，因此，在争用激烈的场景下，CLH 锁能大大减少 CAS 操作的数量，以避免 CPU 总线风暴。</p><blockquote><p>CLH 锁的原理分析</p></blockquote><ol><li>初始化队列尾部属性 tail 指向一个空节点，tail 最好使用 AtomicReference 包装，为了避免多个线程并发操作 tail 时不会发生线程安全问题</li><li>Thread 在抢锁时候会创建一个新的 Node 节点加入等待队列尾部:tail 指向新的 Node, 同时新的 Node 的 preNode 属性指向 tail 之前指向的节点，并且以上操作通过 CAS 自旋完成，以确保操作成功。</li><li>Thread 加入抢锁队列后，会在前驱节点上自旋：循环判断前驱节点的 locked 属性是否为 false, 如果为 false 就表示前驱节点释放了锁，当前线程抢占到锁。</li><li>Thread 抢到锁之后，它的 loacked 属性一直为 true, 一直到临界代码执行完成，然后调用 unlock 方法释放锁，释放之后其 locked 属性才为 fasle。</li></ol><blockquote><p>CLH 锁的优缺点<br>优点：空间复杂度低，如果有 N 个线程，L 个锁，那么需要的存储空间是 O (L+N)<br>缺点：在 NUMA 架构的 CPU 平台上性能很差，CLH 队列所在 NUMA 架构的 CPU 平台上，每个 CPU 内核有自己的内存，如果前驱节点在不同的 CPU 内核上，它的内存位置比较远，在自旋判断前驱节点的 locked 属性时，性能将大打折扣，然后，CLH 所在 SMP 结构的 CPU 平台上则不存在这个问题。</p></blockquote><h1 id="aqs中的node节点"><a class="anchor" href="#aqs中的node节点">#</a> AQS 中的 Node 节点</h1><p>AQS 中是一个 CLH 队列，不存在队列实例，仅存在节点之间的前后关系。Node 节点中核心成员源码如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">//1 取消状态</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">//-1 标识后继线程处于等待状态</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">//-2 标识当前线程正在进行条件等待</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">//-3 标识下一次共享锁 acquireShared 操作需要无条件传播</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 节点状态：值为 SIGNAL、CANCELLED、CONDITION、PROPAGATE、0</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 普通节点的同步节点状态的初始值为 0, 条件等待节点的初始值为 CONDITION (-2)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 前驱节点，当前节点会在前驱节点上自旋，循环检查前驱节点的 waitStatus 状态</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 后继节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    </pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 若当前 Node 不是普通节点而是条件等待节点，则节点处于某个条件的等待队列上，此属性指向下一个等待节点，即条件队列上的后继节点。</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><strong>waitStatus 属性</strong><br>每个节点与等待线程关联，每个节点维护一个状态 waitStatus,waitStatus 的各种值以常量的形式进行定义。waitStatus 的各常量值具体如下:</p><ul><li><p>CANCELLED=1<br>waitState 值为 1 时，表示该线程节点已释放 (超时、中断), 已取消的节点不会再阻塞，表示线程因为中断或者等待超时，需要从等待队列中取消等待。</p></li><li><p>SIGNAL=-1<br>waitStatus 为 SIGNAL (-1) 时表示其后继的节点处于等待状态，当前节点对应的线程如果释放了同步状态或者被取消，就会通知后继节点，使后继节点的线程得以运行</p></li><li><p>CONDITION=-2<br>waitStatus 为 - 2 时，表示该线程在条件队列中阻塞 (Condition 有使用), 表示节点在等待队列中 (这里指的是等待在某个锁的 CONDITION 上), 当持有锁的线程调用了 CODITION 的 signal () 方法之后，节点会从该 CONDITION 的等待队列转移到该锁的同步队列上，去竞争锁。<br>节点处于等待队列中，节点线程等待在 CONDITION 上，当其他线程对 CONDITION 调用了 signal () 方法后，该节点从等待队列中转移到同步队列中，加入对同步状态的获取中。</p></li><li><p>PROPAGATE=-3<br>waitStatus 为 - 3 时，表示下一个线程获取共享锁后，自己的共享状态会被无条件地传播下去，因为共享锁可能出现同时有 N 个锁可以用，这时直接让后面的 N 个节点都来工作。<br>为什么当一个节点的线程获取共享锁后，要唤醒后继共享节点？共享锁是可以多个线程共有的，当一个节点的线程获取共享锁后，必然要通知后继共享节点的线程也可以获取锁了，这样就不会让其他等待的线程等很久，这种向后通知的目的也是尽快同同志其他等待的线程尽快释放锁</p></li><li><p>waitStatus 为 0<br>表示当前节点处于初始状态。<br>Node 结点的 waitStatus 状态为以上 5 中状态的一种。</p></li></ul><p><strong>抢占类型常量标识</strong><br>Node 节点还定义了两个抢占类型常量标识：SHARED 和 EXCLUSIVE, 具体如下:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>       <span class="token comment">// 标识节点在抢占共享锁</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 标识节点在抢占独占锁</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> EXCLUSIVE <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>SHARED 表示线程是因为获取共享资源时阻塞而被添加到队列中的，EXCLUSIVE 表示线程是因为获取独占资源时阻塞而被添加到队列中的。<br>介绍完 Node 节点后，接下来就开始 AQS 的正题了。</p><h1 id="aqs独占锁"><a class="anchor" href="#aqs独占锁">#</a> AQS 独占锁</h1><p>先从 aquire 方法源码分析:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>         <span class="token comment">// 尝试去获取锁，如果没获取成功，就会执行后面的</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 这里首先是将一个独占节点加入到阻塞队列中，然后在 acquireQueued 中继续获取一次锁，获取失败就阻塞</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 注意，acquireQueued 返回的是一个打断标记，如果为 true 将会执行下面的语句</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 这个是传播打断标记</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，这里的代码非常有艺术，使用 &amp; 的特性，如果前面一个函数返回 true, 才会执行后面的函数，也就是如果获取锁失败，那么就会直接执行后面的函数。<br>接下来进入 tryAcquire 方法中，由于 ReentrantLock 中有两种 AQS 的实现，一个是公平锁的，一个是非公平锁的，这里先介绍非公平锁的的 tryAcquire 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token comment">// 获取当前线程</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 获取当前状态</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 如果状态为 0, 说明没有其他线程获取锁</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 使用 CAS, 尝试去修改状态</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    <span class="token comment">// 修改状态成功，即成功获取了锁，将当前线程保存起来</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token comment">// 返回 true, 表示获取锁成功</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 如果状态不为 0, 先判断一下当前线程是否是持有锁的线程，这里是为了锁重入</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 执行到这，说明没有获取锁，直接返回 false</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果 tryAcquire 方法返回 false, 说明尝试 CAS 获取锁失败，直接就会进入 addWaiter 的逻辑:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 这里的 mode, 其实传入的是一个空节点，代表独占节点，通过构造函数将当前线程传入进去</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 这里先是获取尾节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 如果尾节点不为空</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 将当前节点的前驱指向尾节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 将尾节点指针使用 CAS 指向当前节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 如果成功，那么原来的尾节点，也就是前驱节点的 next 指针指向当前节点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 返回当前节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">return</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token comment">// 执行到这里，表示尾节点为空或者 cas 替换尾节点失败，即由其他线程冲突，进入 enq 方法</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其实这个方法，就是构造 Node 节点，然后尝试 CAS 替换尾节点，如果替换失败则进入 enq 方法，下面来看看 enq 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 死循环</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token comment">// 获取尾节点</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 如果尾节点为空，则代表没有初始化</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Must initialize</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 直接通过 CAS 设置一个空的头结点，然后尾节点也指向头结点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    tail <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 进入到这一步，说明尾节点不为空</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 将当前节点的前驱节点设置为尾节点</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token comment">// 这里相当于再次重试将尾节点指针指向当前节点</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token comment">// 如果成功，设置之前的尾节点的 next 指针指向当前节点 (现在的尾节点)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    <span class="token comment">// 直接返回</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token keyword">return</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在 enq 中，采用了一个自旋的方式，如果队列未初始化，就构造一个新的头结点进行初始化，然后第二轮循环就会进入到 else 中，然后就相当于一个不断的 CAS 尝试替换尾节点的操作，只有当替换成功后才能返回。再次回到 addWaiter 方法，enq 方法之后是返回 node, 那么可以得出一个结论，队列其实是在 enq 方法中进行初始化的，并且 enq 方法一定会将节点加入阻塞队列。</p><p>接下来就回到 acquireQueued 方法，由于 addWaiter 已经返回了加入阻塞队列中的节点，这时候就可以分析 acquireQueued 方法了:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 死循环</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token comment">// 由于 node 已经加入阻塞队列，根据 CLH 队列的特性，必定会自旋前驱节点，因此这里先获取一下前驱节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token comment">// 如果前驱节点是头结点，由于头结点其实是个空节点，然后就会再次获取锁</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token comment">// 到这一步，已经获取锁成功了</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token comment">// 直接将当前节点设置为头结点，但是要清空前驱节点和线程，具体看 setHead 方法</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token comment">//p.next 是之前的头结点，这样就不存在引用了，会被 GC 垃圾回收掉</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token comment">// 设置标记，标识不需要取消获取</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token comment">// 直接返回中断标记，目的是为了传播中断</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token comment">// 走到这一步，说明前期节点不是头结点或者尝试获取锁失败，这里要进入一下阻塞的逻辑</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>     <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NullPointerException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token class-name">Node</span> p <span class="token operator">=</span> prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token keyword">return</span> p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>         <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        head <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里还要分析一下 shouldParkAfterFailedAcquire 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 由于 pred 就是 node 节点的前驱，这里是为了获取前驱节点的 waitStatus.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 如果前驱节点的状态是 SIGNAL 状态</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 直接返回 true,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 如果 ws 大于 0, 则说明前驱节点是 CANCEL 取消状态</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token comment">// 这一步，首先是 pred 变量指向前驱节点的前驱节点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token comment">// 然后当前节点的前驱节点指针指向 pred, 通俗来说，就是前驱节点被取消了，当前节点的前驱节点连上了前驱节点的前驱节点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token comment">// 继续检查前驱节点的状态</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 最后将前驱节点的 next 指针指向当前节点。</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 这里就是 0、-2、-3 状态了，也就是普通节点状态和 PROPAGATE 状态</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token comment">// 这里将前驱节点的 waitStatus 状态设置为 SIGNAL, 即前驱节点释放锁后会唤醒当前节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 返回 false</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里其实涉及到了对节点状态的判断，如果 ws==Node.SIGAL 节点，那么就说明当前已经不是第一次进入这个函数了，需要阻塞住。<br>如果是第一次进入这个函数:<br>前驱节点的状态如果是 1, 也就说前驱节点被取消，那么就会继续往前找到新的前驱结果，然后返回 false. 不需要阻塞<br>前驱节点的状态是 0、-2、-3, 那么设置前驱节点的状态为 - 1, 也就是 SIGAL。不需要阻塞。</p><p>接下来进入真正实现阻塞逻辑的函数 parkAndCheckInterrupt ()</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 阻塞当前线程</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 当被唤醒的时候，通过 Thread.interrupted 判断是被打断还是被 unpark</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个函数比较好理解，回到之前:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果 parkAndCheckInterrupt 返回 true, 说明打断标记为 true, 也就是被打断的，将 interrupt 设置为 true, 传播打断标记。<br>接下来进入最后一个方法:cancelAcquire</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 如果节点不存在，直接返回</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 节点存在，将保存的线程设置为 null</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 获取前一个节点</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token class-name">Node</span> pred <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 状态大于 0, 一定是 1, 即 Cancel 状态，继续往前遍历</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 获取前一个节点的 next 节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token class-name">Node</span> predNext <span class="token operator">=</span> pred<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 设置节点的状态为取消状态</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 如果节点的尾节点，则将尾节点指针用 CAS 替换到前一个节点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token comment">// 替换成功后，由于取消尾节点，那么前一个节点的 next 节点要设置为 null</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 如果节点不是尾节点</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">int</span> ws<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>             <span class="token comment">// 如果前驱节点不是 head, 并且，前驱节点的 waitStatus 状态为 SIGNAL 或者是 前驱节点状态 & lt;=0，并且能将前驱节点的状态修改为 SIGNAL</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> head <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL <span class="token operator">||</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                 <span class="token punctuation">(</span>ws <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                pred<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                    <span class="token comment">// 先获取当前节点的后继节点</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                <span class="token class-name">Node</span> next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                <span class="token comment">// 如果存在后继节点，并且状态小于等于 0 (-3, -2 ,-1 ,0)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                <span class="token comment">// 将前驱节点的的 next 设置为当前节点的后继节点</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                    <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token comment">// 当前前驱节点为 head 节点的时候，唤醒当前节点</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>            node<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment">// help GC</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个方法的逻辑就是取消节点，其实就是将节点状态修改为 CANCEL (1), 要先检查前驱节点是否也为 CANCEL, 往前找到第一个不为 CANCEL 状态的前驱节点，目的是为了将当前节点从后继节点移除，但是如果当前节点的前驱节点就是 head, 那么则会唤醒当前节点，重新竞争一下锁。<br>这个方法的发生时机应该是处于异常的时候，因为它处于 finally 块中。<br>下面来看一下真正唤醒的方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token comment">// 获取要唤醒节点的状态</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 如果 waitStatus&lt;0, 那么 waitStatus 状态只能是 - 1 (SIGNAL)、-2 (CONDITION)、-3 (PROGATION)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>         <span class="token comment">// 这里是直接将节点状态替换为正常节点，也就是说，除了 CANCEL 状态，都要恢复成初始节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 获取下一个节点</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 如果当前 node 是尾节点或者 next 节点等待状态 > 0 (处于 CANCEL 状态)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token comment">// 从尾节点开始，遍历到当前的 node 节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 这里找到 node 之后第一个非取消的节点</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    s <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 如果 s 不为空</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 唤醒 s 的线程</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>从实现逻辑中可以看出，unparkSuccessor (node) 唤醒的并不是 node 节点，而是 node 节点之后的第一个非取消状态的节点。<br>这时候，可以回过头看看 acquireQueued 方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 死循环</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>               </pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>              </pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                   </pre></td></tr><tr><td data-num="14"></td><td><pre>                    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                   </pre></td></tr><tr><td data-num="16"></td><td><pre>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                   </pre></td></tr><tr><td data-num="18"></td><td><pre>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    </pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// 节点会从 parkAndCheckInterrupt 方法中醒来，由于是 unpark 唤醒的，因此会返回 false, 不会执行 interrupted = true;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token comment">// 然后继续进入死循环，也就是自旋前驱节点，尝试获得锁。</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接下来分析一下释放锁的逻辑，可以看到 release 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 尝试去释放锁，即通过 CAS 修改状态 state</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token comment">// 如果释放锁成功，</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 获取头结点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 如果头结点不为空并且非 0</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 唤醒后继节点</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>进入 tryRelease 方法中:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            </pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">return</span> free<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码不难理解，可以发现并没有使用 CAS, 这是因为锁是独占锁，获取锁的线程只有一个，因此不存在线程安全问题。直接修改状态即可。<br>以上都是非公平锁的实现方式。</p><p>下面看看公平锁的获取方式:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token comment">// 这里多了个 hasQueuedPredecessors 方法判断是否有前驱节点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                    <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// The correctness of this depends on head being initialized</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// before tail and on head.next being accurate if the current</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// thread is first in queue.</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment">// Read fields in reverse initialization order</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">Node</span> s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 如果节点个数大于 1 个，并且头节点的 next 不指向当前节点，就说明不能获取锁，要排队！！！</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以发现，非公平锁就多了个 hasQueuedPredecessors, 只要前驱节点是头结点，才能获取锁。保证了公平性。</p><p>到这里，AQS 独占锁源码解析就差不多了，但是还有个共享锁并没有分析，由于 ReentrantLock 是独占锁，所以本篇不再叙述共享锁。<br>那么做一个 AQS 独占锁的小总结:++ 首先，AQS 是一个同步器，它是由并发大师 DougLea 开发的，内部维护了一个 CLH 变种队列，使用了一种模板方法设计模式，也就是如果要实现自定义的组件，可以聚合 AQS 同步器，委托给 AQS 同步器去做，核心原理就是将线程包装成一个个队列节点，首节点代表获取锁的线程节点，通过对 state 状态变量进行 CAS 操作，如果 CAS 失败，则通过 addWaiter 方法加入同步队列，在加入同步队列的方法中，有个 enq 方法，思路是使用自旋也就是死循环的方式，将节点加入队尾。加入完后返回当前节点，调用 acquireQueued 方法，传入当前节点作为形参，这个方法的思路是处于一个死循环中，再次重新获取一下锁，如果失败，需要判断一下是否符合阻塞的条件，如果符合，则调用 Unsafe.park 方法阻塞住，否则就不阻塞。阻塞需要等待唤醒，唤醒之后继续死循环。+<br>+</p><h1 id="reentrantlock源码解析"><a class="anchor" href="#reentrantlock源码解析">#</a> ReentrantLock 源码解析</h1><p>下面正式进入 ReentrantLock 源码解析:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7373984872572414699L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 聚合了一个 Sync</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//sync 是一个内部类，可以看到继承了 AQS</span></pre></td></tr><tr><td data-num="7"></td><td><pre>     <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5179523762034025860L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>     <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     <span class="token comment">// 又有一个 Sync 实现内部类，从名字可以看出，是非公平锁的实现</span></pre></td></tr><tr><td data-num="12"></td><td><pre>       <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7316153563782823691L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>     </pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 公平锁</span></pre></td></tr><tr><td data-num="29"></td><td><pre>       <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3000897897090466540L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token annotation punctuation">@ReservedStackAccess</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>                    <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>                    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="49"></td><td><pre>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>                <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="53"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre></pre></td></tr><tr><td data-num="57"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="58"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>继续看一下构造方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，这里有两个构造方法，无参构造默认的 sync 实现是非公平锁，有参构造是根据传入的 fair, 去判断是用公平锁还是非公平锁<br>继续看看 lock 接口定义的方法实现:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 这里直接委托给了 sync 的 lock 方法</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 这里也是委托给 sync</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        sync<span class="token punctuation">.</span><span class="token function">acquireInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看到这里，其实整个 ReentrantLock 就十分清晰了，所有方法都是委托给 AQS, 由于 AQS 定义了一些抽象方法比如 tryAcquire, 这些方法都在 ReentrantLock 的内部类 NonFairSync 和 FairSync 中实现了，也就是其实 ReentrantLock 中也就实现了 AQS 中的抽象方法，通过这些抽象方法对 state 变量进行操作，而到达实现各种组件的目的。这也就是模板方法设计模式的好处。</p><p>下面介绍一下 ConditonObject, 相信使用过 ReentrantLock 都不会陌生，这个是个等待队列，可以实现 wait/notify 一样的效果。那么下面来看看源码:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Lock</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>其实这个方法是在 Lock 接口中定义的，在 ReenrantLock 中实现的:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token class-name">Condition</span> <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，其实也是委托给了 sync。</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionObject</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1173984872572414699L</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 等待队列中的头节点</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 等待队列中的尾节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里其实直接 new 了一个 ConditonObject, 这个类是一个内部类，可以到这个类其实是个双向链表。这个类实现了 Condition 接口:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Condition</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">boolean</span> <span class="token function">awaitUntil</span><span class="token punctuation">(</span><span class="token class-name">Date</span> deadline<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>下面看看这些方法的具体实现，首先是 await () 方法:</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token comment">// 先检查线程的中断标志，如果被中断，直接抛出异常</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>                </pre></td></tr><tr><td data-num="6"></td><td><pre>                <span class="token comment">// 将节点添加到等待队列中</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token comment">// 释放当前节点线程持有的锁 (将 state 修改为 0), 这里需要保存下锁状态</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token comment">// 如果不在阻塞队列</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 直接阻塞</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 执行到这说明被唤醒或者之前的 while 判断在阻塞队列中，尝试去获取锁</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token comment">// 如果该节点后还有等待队列，清理下被取消的节点</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token comment">//</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                <span class="token comment">// 等待队列中的尾节点</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token class-name">Node</span> t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token comment">// If lastWaiter is cancelled, clean out.</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token comment">// 如果尾节点不为空，并且尾节点的的 waitStatus 不是 CONDITION (-2), 说明尾节点取消</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>                <span class="token comment">// 重新定位尾节点</span></pre></td></tr><tr><td data-num="36"></td><td><pre>                <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token comment">// 如果尾节点为空，说明等待队列为空，新建一个 waitStatus 状态为 CONDITION 的节点</span></pre></td></tr><tr><td data-num="40"></td><td><pre>            <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token comment">// 如果尾节点为空</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token comment">// 当前节点就作为队列的第一个节点，firstWaiter 指针指向它</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                <span class="token comment">// 如果尾节点不为空，则尾节点的 nextWaiter 指向当前新建节点</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token keyword">else</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>                <span class="token comment">// 尾节点指针也指向当前节点</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>            <span class="token keyword">return</span> node<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="52"></td><td><pre></pre></td></tr><tr><td data-num="53"></td><td><pre>            <span class="token comment">// 这个函数的作用是，取消状态不为 CONDITION 的节点，将剩余的节点重新链接起来</span></pre></td></tr><tr><td data-num="54"></td><td><pre>           <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>            <span class="token class-name">Node</span> t <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="56"></td><td><pre>            <span class="token class-name">Node</span> trail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="57"></td><td><pre>            <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="58"></td><td><pre>                <span class="token comment">// 遍历</span></pre></td></tr><tr><td data-num="59"></td><td><pre>                <span class="token class-name">Node</span> next <span class="token operator">=</span> t<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="60"></td><td><pre>                <span class="token comment">// 从头开始遍历，如果找到状态不为 CONDITION 的节点</span></pre></td></tr><tr><td data-num="61"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="62"></td><td><pre>                    t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="63"></td><td><pre>                    <span class="token comment">///trail 为空</span></pre></td></tr><tr><td data-num="64"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>trail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="65"></td><td><pre>                    <span class="token comment">// 头结点指直接指向 t 的后继节点。</span></pre></td></tr><tr><td data-num="66"></td><td><pre>                        firstWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="67"></td><td><pre>                    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="68"></td><td><pre>                    <span class="token comment">//trail 不为空，移除当前的 t,trail 的后继 waiter 指向 next</span></pre></td></tr><tr><td data-num="69"></td><td><pre>                        trail<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="70"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="71"></td><td><pre>                        lastWaiter <span class="token operator">=</span> trail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="72"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="73"></td><td><pre>                <span class="token comment">// 如果是 CONDITION 节点</span></pre></td></tr><tr><td data-num="74"></td><td><pre>                <span class="token keyword">else</span></pre></td></tr><tr><td data-num="75"></td><td><pre>                <span class="token comment">//trail 即是当前节点</span></pre></td></tr><tr><td data-num="76"></td><td><pre>                    trail <span class="token operator">=</span> t<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="77"></td><td><pre>                </pre></td></tr><tr><td data-num="78"></td><td><pre>                t <span class="token operator">=</span> next<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="79"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="80"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="81"></td><td><pre></pre></td></tr><tr><td data-num="82"></td><td><pre>           <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="83"></td><td><pre>        <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="84"></td><td><pre>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="85"></td><td><pre>            <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="86"></td><td><pre>            <span class="token comment">// 释放锁</span></pre></td></tr><tr><td data-num="87"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">release</span><span class="token punctuation">(</span>savedState<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="88"></td><td><pre>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="89"></td><td><pre>                <span class="token keyword">return</span> savedState<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="90"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="91"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="92"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="93"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="94"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="95"></td><td><pre>                node<span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CANCELLED<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="96"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="97"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="98"></td><td><pre></pre></td></tr><tr><td data-num="99"></td><td><pre>        <span class="token comment">// 是否在阻塞队列</span></pre></td></tr><tr><td data-num="100"></td><td><pre>     <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="101"></td><td><pre></pre></td></tr><tr><td data-num="102"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>waitStatus <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION <span class="token operator">||</span> node<span class="token punctuation">.</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="103"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="104"></td><td><pre>            <span class="token comment">// 如果有后继节点，一定是在阻塞队列</span></pre></td></tr><tr><td data-num="105"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// If has successor, it must be on queue</span></pre></td></tr><tr><td data-num="106"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="107"></td><td><pre>        <span class="token comment">// 看看节点是否处于阻塞队列中</span></pre></td></tr><tr><td data-num="108"></td><td><pre>        <span class="token keyword">return</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="109"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="110"></td><td><pre>    <span class="token comment">// 从后往前找节点</span></pre></td></tr><tr><td data-num="111"></td><td><pre>       <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">findNodeFromTail</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="112"></td><td><pre>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="113"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="114"></td><td><pre>            <span class="token comment">// 如果找到 node, 直接返回 true</span></pre></td></tr><tr><td data-num="115"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> node<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="116"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="117"></td><td><pre>                <span class="token comment">// 如果尾部为 null, 直接返回 fasle</span></pre></td></tr><tr><td data-num="118"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="119"></td><td><pre>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="120"></td><td><pre>            t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="121"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="122"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>await 方法还是比较复杂的，整体流程如下:</p><ol><li>检查线程中断标志，如果被中断，直接抛异常</li><li>将节点添加到阻塞队列中</li><li>释放当前节点线程持有的锁，并保存一下锁状态</li><li>判断是否还在阻塞队列中，如果不在阻塞队列中，直接阻塞</li><li>被 singal 唤醒后，就用之前保存的锁状态去尝试获取锁</li></ol><p>接下来看看 signal</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>            <span class="token comment">// 只有持有锁，才有使用 signal</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token class-name">Node</span> first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// 从等待队列的第一个节点开始唤醒</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 从等待队列头结点开始，知道唤醒一个为止</span></pre></td></tr><tr><td data-num="11"></td><td><pre>         <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token comment">// 如果等待队列中只有一个节点，将队列首节点和尾节点指针置 NULL</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                    lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                     <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 如果不能改变 WaitStatus 状态，则说明节点被取消，直接返回 false。</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token comment">/*</span></pre></td></tr><tr><td data-num="27"></td><td><pre>         * Splice onto queue and try to set waitStatus of predecessor to</pre></td></tr><tr><td data-num="28"></td><td><pre>         * indicate that thread is (probably) waiting. If cancelled or</pre></td></tr><tr><td data-num="29"></td><td><pre>         * attempt to set waitStatus fails, wake up to resync (in which</pre></td></tr><tr><td data-num="30"></td><td><pre>         * case the waitStatus can be transiently and harmlessly wrong).</pre></td></tr><tr><td data-num="31"></td><td><pre>         */</pre></td></tr><tr><td data-num="32"></td><td><pre>         <span class="token comment">// 进行到这一步，使用 enq 将节点重新加入阻塞队列，获取 node 在 AQS 队列中前驱节点的状态</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token comment">// 如果 waitStatus 被取消或者不能替换成 SIGNAL, 就唤醒当前节点</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token comment">// 唤醒节点</span></pre></td></tr><tr><td data-num="38"></td><td><pre>            <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>            <span class="token comment">// 否则直接在阻塞队列里排队。</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>signal 方法还是比较容易理解的，其实就是从等待队列的第一个节点开始，进行唤醒，如果唤醒失败 (节点被取消), 就唤醒下一个。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p><strong>总的来说，AQS 还是比较复杂的，但是去看里面的源码，才会发现编程的魅力，DougLea 深厚的编码能力，代码写的十分优雅，以及其中的思想值得学习。</strong></p><div class="tags"><a href="/tags/Java/" rel="tag"><i class="ic i-tag"></i> Java</a> <a href="/tags/%E9%94%81/" rel="tag"><i class="ic i-tag"></i> 锁</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-11-02 14:30:32" itemprop="dateModified" datetime="2022-11-02T14:30:32+08:00">2022-11-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>故犹 <i class="ic i-at"><em>@</em></i>努力走,走到灯火通明</li><li class="link"><strong>本文链接：</strong> <a href="https://guyouwyh.github.io/guyouwyh/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ReentryLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="ReentryLock源码分析">https://guyouwyh.github.io/guyouwyh/2022/11/01/后端/Java/Java并发/ReentryLock源码解析/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/LongAddr/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2021&#x2F;12&#x2F;15&#x2F;Fdim5YeA7pl6tTj.jpg" title="LongAdder源码分析"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java并发</span><h3>LongAdder源码分析</h3></a></div><div class="item right"><a href="/2022/11/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2021&#x2F;12&#x2F;15&#x2F;fV3IslvSQ86qJpj.jpg" title="ThreadLocal源码分析"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java并发</span><h3>ThreadLocal源码分析</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#reentrylock%E7%9A%84%E7%BB%A7%E6%89%BF%E9%93%BE"><span class="toc-number">1.</span> <span class="toc-text">ReentryLock 的继承链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">2.</span> <span class="toc-text">锁的可重入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">锁的设计思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.</span> <span class="toc-text">公平锁和非公平锁的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">Lock 接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#clh%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">CLH 锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#aqs%E4%B8%AD%E7%9A%84node%E8%8A%82%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">AQS 中的 Node 节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#aqs%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">AQS 独占锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reentrantlock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">ReentrantLock 源码解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/JMM%E5%92%8Cvolatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" rel="bookmark" title="JMM和volatile的一些理解">JMM和volatile的一些理解</a></li><li><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="Atomic原子类源码解析">Atomic原子类源码解析</a></li><li><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/LongAddr/" rel="bookmark" title="LongAdder源码分析">LongAdder源码分析</a></li><li class="active"><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ReentryLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="ReentryLock源码分析">ReentryLock源码分析</a></li><li><a href="/2022/11/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="bookmark" title="ThreadLocal源码分析">ThreadLocal源码分析</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="故犹" data-src="/images/avatar.jpg"><p class="name" itemprop="name">故犹</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">5</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1eW91d3lo" title="https:&#x2F;&#x2F;github.com&#x2F;guyouwyh"><i class="ic i-github"></i></span> <a href="/821403296@qq.com" title="821403296@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-link"></i>友链</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-magic"></i>常用网站</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/LongAddr/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/11/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/" title="分类于 Java并发">Java并发</a></div><span><a href="/2022/11/02/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="ThreadLocal源码分析">ThreadLocal源码分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/" title="分类于 Java并发">Java并发</a></div><span><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/LongAddr/" title="LongAdder源码分析">LongAdder源码分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/" title="分类于 Java并发">Java并发</a></div><span><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/JMM%E5%92%8Cvolatile%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" title="JMM和volatile的一些理解">JMM和volatile的一些理解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/" title="分类于 Java并发">Java并发</a></div><span><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/ReentryLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="ReentryLock源码分析">ReentryLock源码分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/" title="分类于 Java并发">Java并发</a></div><span><a href="/2022/11/01/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Atomic原子类源码解析">Atomic原子类源码解析</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">故犹 @ GuYou</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">46k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">42 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/11/01/后端/Java/Java并发/ReentryLock源码解析/",favicon:{show:"加载中",hide:"OvO"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->