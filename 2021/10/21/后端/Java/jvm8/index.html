<!-- build time:Sun Apr 17 2022 19:16:34 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/rss.xml"><link rel="alternate" type="application/atom+xml" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/atom.xml"><link rel="alternate" type="application/json" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="jvm"><link rel="canonical" href="https://guyouwyh.github.io/guyouwyh/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm8/"><title>JVM笔记(八)-类加载的三个阶段 - Java基础 - 后端 | GuYou = 努力走,走到灯火通明</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JVM笔记(八)-类加载的三个阶段</h1><div class="meta"><span class="item" title="创建时间：2021-10-21 20:17:30"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-10-21T20:17:30+08:00">2021-10-21</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>6 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">GuYou</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2021/12/15/B735tDMiU2eZFjK.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/GZxwX8Q7EHtjP3B.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/81NwWC7IL46svDA.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/z4byuMFYqEKQS2O.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/nQSr6Dxua7pIvlB.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/fV3IslvSQ86qJpj.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="item" rel="index" title="分类于 后端"><span itemprop="name">后端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%90%8E%E7%AB%AF/Java/" itemprop="item" rel="index" title="分类于 Java基础"><span itemprop="name">Java基础</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://guyouwyh.github.io/guyouwyh/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="故犹"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="努力走,走到灯火通明"></span><div class="body md" itemprop="articleBody"><h1 id="类的加载"><a class="anchor" href="#类的加载">#</a> 类的加载</h1><blockquote><h2 id="在java中数据类型分为基本数据类型和引用数据类型-基本数据-类型由虚拟机预先定义引用数据类型则需要进行类的加载-按照java虚拟机规范从class文件到加载到内存中的类到-类卸载出内存为止它的整个生命周期包括如下7个阶段"><a class="anchor" href="#在java中数据类型分为基本数据类型和引用数据类型-基本数据-类型由虚拟机预先定义引用数据类型则需要进行类的加载-按照java虚拟机规范从class文件到加载到内存中的类到-类卸载出内存为止它的整个生命周期包括如下7个阶段">#</a> 在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据 类型由虚拟机预先定义，引用数据类型则需要进行类的加载 按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到 类卸载出内存为止，它的整个生命周期包括如下 7 个阶段</h2></blockquote><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gueyvp6n1lj60n309v75102.jpg" alt="在这里插入图片描述"></p><h2 id="加载阶段"><a class="anchor" href="#加载阶段">#</a> 加载阶段</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>加载的理解</pre></td></tr><tr><td data-num="2"></td><td><pre>所谓加载，简而言之就是将<span class="token class-name">Java</span>类的字节码文件加载到机器内存中，</pre></td></tr><tr><td data-num="3"></td><td><pre>并在内存中构建出<span class="token class-name">Java</span>类的原型一一类模板对象。所谓类模板对象，</pre></td></tr><tr><td data-num="4"></td><td><pre>其实就是<span class="token class-name">Java</span>类JVM内存中的一个快照JVMM将从字节码文件中</pre></td></tr><tr><td data-num="5"></td><td><pre>解析出的常量池、类字段、类方法等信息</pre></td></tr><tr><td data-num="6"></td><td><pre>存储到类模板中，这样JVM在运行期便能通过类模板而获取<span class="token class-name">Java</span></pre></td></tr><tr><td data-num="7"></td><td><pre>类中的任意信息，能够对<span class="token class-name">Java</span>类的成员变量进行遍历，也能</pre></td></tr><tr><td data-num="8"></td><td><pre>进行<span class="token class-name">Java</span>方法的调用。</pre></td></tr><tr><td data-num="9"></td><td><pre>反射的机制即基于这一基础。如果JVM没有将<span class="token class-name">Java</span>类的声明信息</pre></td></tr><tr><td data-num="10"></td><td><pre>存储起来，则JVM在运行期也无法反射。</pre></td></tr><tr><td data-num="11"></td><td><pre>加载完成的操作</pre></td></tr><tr><td data-num="12"></td><td><pre>加载阶段，简言之，查找并加载类的二进制数据，生成<span class="token class-name">Class</span>的实例</pre></td></tr><tr><td data-num="13"></td><td><pre>在加载类时，<span class="token class-name">Java</span>虚拟机必须完成以下<span class="token number">3</span>件事情</pre></td></tr><tr><td data-num="14"></td><td><pre>通过类的全名，获取类的二进制数据流</pre></td></tr><tr><td data-num="15"></td><td><pre>解析类的二进制数据流为方法区内的数据结构<span class="token punctuation">(</span><span class="token class-name">Java</span>类模型<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>创建<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Class</span>类的实例，表示该类型。作为方法区这个类的</pre></td></tr><tr><td data-num="17"></td><td><pre>各种数据的访问入口</pre></td></tr></table></figure><blockquote><h2 id="二进制流的获取方式"><a class="anchor" href="#二进制流的获取方式">#</a> 二进制流的获取方式</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span>只要所读取的字节码符合JVM规范即可<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>虚拟机可能通过文件系统读入一个<span class="token keyword">class</span>后缀的文件（最常见）</pre></td></tr><tr><td data-num="4"></td><td><pre>读入jar、zip等归档数据包，提取类文件。</pre></td></tr><tr><td data-num="5"></td><td><pre>事先存放在数据库中的类的二进制数</pre></td></tr><tr><td data-num="6"></td><td><pre>使用类似于HTP之类的协议通过网络进行加载</pre></td></tr><tr><td data-num="7"></td><td><pre>在运行时生成一段<span class="token class-name">Class</span>的二进制信息等</pre></td></tr><tr><td data-num="8"></td><td><pre>在获取到类的二进制信息后，<span class="token class-name">Java</span>虚拟机就会处理这些数据，</pre></td></tr><tr><td data-num="9"></td><td><pre>并最终转为一个<span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Class</span>的实例。</pre></td></tr><tr><td data-num="10"></td><td><pre>如果输入数据不是<span class="token class-name">Classfilel</span>的结构，则会抛出</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token class-name">Classformaterror</span>。</pre></td></tr></table></figure><blockquote><h2 id="类模型与class实例的位置"><a class="anchor" href="#类模型与class实例的位置">#</a> 类模型与 Class 实例的位置</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1</span> 类模型的位置</pre></td></tr><tr><td data-num="2"></td><td><pre>加载的类在JVM中创建相应的类结构，类结构会存储在方法区</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span>JDK1<span class="token punctuation">.</span><span class="token number">8</span>之前：永久代：JDK1<span class="token punctuation">.</span><span class="token number">8</span>及之后：元空间<span class="token punctuation">)</span>。</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">2</span> <span class="token class-name">Class</span>实例的位置</pre></td></tr><tr><td data-num="5"></td><td><pre>类将<span class="token punctuation">.</span><span class="token keyword">class</span>文件加载至元空间后，会在堆中创建一个</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">]</span><span class="token class-name"><span class="token namespace">ava<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Class</span>对象，用来封装类位于方法区内的数据结构，该</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token class-name">Class</span>对象是在加载类的过程中创建的，每个类都对应有一个<span class="token class-name">Class</span></pre></td></tr><tr><td data-num="8"></td><td><pre>类型的对象。</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>外部可以通过访问代表<span class="token class-name">Order</span>类的<span class="token keyword">class</span>对象来获取 <span class="token class-name">Orderl</span>的</pre></td></tr><tr><td data-num="11"></td><td><pre>类数据结构。</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre> 再说明</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token class-name">Class</span>类的构造方法是私有的，只有JVM能够创建。</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Class</span>实例是访问类型元数据的接口，也是实现反射的关</pre></td></tr><tr><td data-num="16"></td><td><pre>键数据、入口。通过<span class="token class-name">Class</span>类提供的接口，可以获得目标类所关</pre></td></tr><tr><td data-num="17"></td><td><pre>联<span class="token punctuation">.</span><span class="token keyword">class</span>文件中具体的数据结构：方法、字段等信息。</pre></td></tr></table></figure><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1gueyxeelcoj60d20dhmxm02.jpg" alt="在这里插入图片描述"></p><blockquote><h2 id="数组类的加载"><a class="anchor" href="#数组类的加载">#</a> 数组类的加载</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载</pre></td></tr><tr><td data-num="2"></td><td><pre>器负责创建，而是由JVM在运行时根据需要而直接创建的</pre></td></tr><tr><td data-num="3"></td><td><pre>但数组的元素类型仍然需要依靠类加载器去创建。创建数组</pre></td></tr><tr><td data-num="4"></td><td><pre>类<span class="token punctuation">(</span>下述简称<span class="token class-name">A</span><span class="token punctuation">)</span>的过程：</pre></td></tr><tr><td data-num="5"></td><td><pre>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递</pre></td></tr><tr><td data-num="6"></td><td><pre>归加载和创建数组<span class="token class-name">A</span>的元素类型</pre></td></tr><tr><td data-num="7"></td><td><pre>JVM使用指定的元素类型和数组维度来创建新的数组类。</pre></td></tr><tr><td data-num="8"></td><td><pre>如果数组的元素类型是引用类型，数组类的可访问性就由元素类</pre></td></tr><tr><td data-num="9"></td><td><pre>型的可访问性决定。否则数组类的可访问性将被缺省定义为<span class="token class-name">Public</span>。</pre></td></tr></table></figure><h2 id="链接阶段"><a class="anchor" href="#链接阶段">#</a> 链接阶段</h2><blockquote><h2 id="验证阶段verification"><a class="anchor" href="#验证阶段verification">#</a> 验证阶段 (Verification)</h2></blockquote><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。 它的目的是保证加载的字节码是合法、合理并符合规范的。 验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚 拟机需要做以下检査，如图所示</p><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guez0xvvnxj60to0r0acj02.jpg" alt="image-20210913141222247"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>整体说明：</pre></td></tr><tr><td data-num="2"></td><td><pre>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，</pre></td></tr><tr><td data-num="3"></td><td><pre>以及符号引用验证等。</pre></td></tr><tr><td data-num="4"></td><td><pre>其中格式验证会和加载阶段一起执行。验证通过之后，类加载器</pre></td></tr><tr><td data-num="5"></td><td><pre>オ会成功将类的二进制数据信息加载到方法区中。</pre></td></tr><tr><td data-num="6"></td><td><pre>格式验证之外的验证操作将会在方法区中进行</pre></td></tr><tr><td data-num="7"></td><td><pre>链接阶段的验证虽然拖慢了加载速度但是它免了在字节码运行时</pre></td></tr><tr><td data-num="8"></td><td><pre>还需要进行各种检查。（磨刀不误砍柴工）</pre></td></tr><tr><td data-num="9"></td><td><pre>具体说明：</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">1</span> 格式验证：是否以魔数 OXCAFEBABE开头，主版本和副版本号</pre></td></tr><tr><td data-num="11"></td><td><pre>是否在当前<span class="token class-name">Java</span>虚拟机的支持范围内，数据中每一个项是否都拥有</pre></td></tr><tr><td data-num="12"></td><td><pre>正确的长度等</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token number">2</span> <span class="token class-name">Java</span>拟机会进行字节码的语义检查，但凡在语义上不符合规范</pre></td></tr><tr><td data-num="15"></td><td><pre>的，虚拟机也不会给予验证通过。比如</pre></td></tr><tr><td data-num="16"></td><td><pre>是否所有的类都有父类的存在<span class="token punctuation">(</span>在<span class="token class-name">Java</span>里，除了 object外，其他</pre></td></tr><tr><td data-num="17"></td><td><pre>类都应该有父类<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>是否一些被定义为finaL的方法或者类被重写或继承了</pre></td></tr><tr><td data-num="19"></td><td><pre>非抽象类是否实现了所有抽象方法或者接口方法</pre></td></tr><tr><td data-num="20"></td><td><pre>是否存在不兼容的方法（比如方法的签名除了返回值不同，其</pre></td></tr><tr><td data-num="21"></td><td><pre>他都一样，这种方法会让虚拟机无从下手调度； <span class="token keyword">abstract</span>情况</pre></td></tr><tr><td data-num="22"></td><td><pre>下的方法，就不能是fina的了）</pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token number">3</span> <span class="token class-name">Java</span>虚拟机还会进行字节码验证，字节码验证也是验证过程中最为</pre></td></tr><tr><td data-num="25"></td><td><pre>复杂的一个过程。它试图通过对字节码流的分析，判断字节</pre></td></tr><tr><td data-num="26"></td><td><pre>码是否可以被正确地执行。比如：</pre></td></tr><tr><td data-num="27"></td><td><pre>在字节码的执行过程中，是否会跳转到一条不存在的指令</pre></td></tr><tr><td data-num="28"></td><td><pre>函数的调用是否传递了正确类型的参数</pre></td></tr><tr><td data-num="29"></td><td><pre>变量的赋值是不是给了正确的数据类型等</pre></td></tr><tr><td data-num="30"></td><td><pre>栈映射帧<span class="token punctuation">(</span> <span class="token class-name">StackMaptable</span><span class="token punctuation">)</span>就是在这个阶段，用于检测在特定的字</pre></td></tr><tr><td data-num="31"></td><td><pre>节码处，其局部变量表和操作数栈是否有着正确的数据类型。</pre></td></tr><tr><td data-num="32"></td><td><pre>但遗憾的是，<span class="token number">100</span><span class="token operator">%</span>准确地判断一段字节码是否可以被安全执行是</pre></td></tr><tr><td data-num="33"></td><td><pre>无法实现的，因此，该过程只是尽可能地检査出可以预知的明显</pre></td></tr><tr><td data-num="34"></td><td><pre>的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个</pre></td></tr><tr><td data-num="35"></td><td><pre>类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没</pre></td></tr><tr><td data-num="36"></td><td><pre>有问题的</pre></td></tr></table></figure><blockquote><h2 id="准备阶段"><a class="anchor" href="#准备阶段">#</a> 准备阶段</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>准备阶段<span class="token punctuation">(</span> <span class="token class-name">Preparation</span><span class="token punctuation">)</span><span class="token punctuation">,</span>简言之，为类的静态变量分配内存，并将</pre></td></tr><tr><td data-num="2"></td><td><pre>其初始化为默认值</pre></td></tr><tr><td data-num="3"></td><td><pre>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，</pre></td></tr><tr><td data-num="4"></td><td><pre>虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。</pre></td></tr><tr><td data-num="5"></td><td><pre>java虚拟机为各类型变量默认的初始值如表所示。</pre></td></tr></table></figure><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guez26nbipj60jn09haac02.jpg" alt="在这里插入图片描述"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>注意：<span class="token class-name">Java</span>并不支持 <span class="token keyword">boolean</span>类型，对于 <span class="token keyword">boolean</span>类型，内</pre></td></tr><tr><td data-num="2"></td><td><pre>部实现是<span class="token keyword">int</span><span class="token punctuation">,</span>由于<span class="token keyword">int</span>的默认值是<span class="token number">0</span><span class="token punctuation">,</span>故对应的，<span class="token keyword">boolean</span>的默认</pre></td></tr><tr><td data-num="3"></td><td><pre>值就是<span class="token boolean">false</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>注意</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">1</span> 这里不包含基本数据类型的字段用 <span class="token keyword">static</span> <span class="token keyword">final</span>修饰的情況，因</pre></td></tr><tr><td data-num="7"></td><td><pre>为<span class="token keyword">final</span>在编译的时候就会分配了，准备阶段会显式赋值。如果有<span class="token keyword">static</span> <span class="token keyword">final</span>指向一个<span class="token keyword">new</span>的引用类型<span class="token punctuation">,</span>是在初始化阶段进行赋值</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">2</span> 注意这里不会为实例变量分配初始化，类变量会分配在方法</pre></td></tr><tr><td data-num="9"></td><td><pre>区中，而实例变量是会随着对象一起分配到<span class="token class-name">Java</span>堆中。</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">3</span> 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行</pre></td></tr></table></figure><blockquote><h2 id="解析阶段"><a class="anchor" href="#解析阶段">#</a> 解析阶段</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>解析阶段<span class="token punctuation">(</span> <span class="token class-name">Resolution</span><span class="token punctuation">)</span><span class="token punctuation">,</span>简言之，将类、接口、字段和方法的符号</pre></td></tr><tr><td data-num="2"></td><td><pre>引用转为直接引用。 </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">1</span> 具体描述</pre></td></tr><tr><td data-num="4"></td><td><pre>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和</pre></td></tr><tr><td data-num="5"></td><td><pre>和内存布局无关。比较容易理解的就是在<span class="token class-name">Class</span>类文件中</pre></td></tr><tr><td data-num="6"></td><td><pre>通过常量池进行了大量的符号引用。但是在程序实际运行时，只</pre></td></tr><tr><td data-num="7"></td><td><pre>有符号引用是不够的，比如当如下 printin（）方法被</pre></td></tr><tr><td data-num="8"></td><td><pre>调用时，系统需要明确知道该方法的位置。</pre></td></tr><tr><td data-num="9"></td><td><pre>举例：输出操作 <span class="token class-name">System</span><span class="token punctuation">,</span>out<span class="token punctuation">.</span> printin（）对应的字节码</pre></td></tr><tr><td data-num="10"></td><td><pre>invokevirtual #<span class="token number">24</span> <span class="token operator">&lt;</span>java<span class="token operator">/</span>io<span class="token operator">/</span><span class="token class-name">Printstream</span> println<span class="token operator">></span></pre></td></tr></table></figure><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guez4eus1nj61ck0lajt902.jpg" alt="image-20210913141542406"></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>以方法为例，<span class="token class-name">Java</span>虚拟机为每个类都准备了一张方法表，将其所</pre></td></tr><tr><td data-num="2"></td><td><pre>有的方法都列在表中，当需要调用一个类的方法的时位</pre></td></tr><tr><td data-num="3"></td><td><pre>只要知道这个方法在方法表中的偏移量就可以直接调用该方法。</pre></td></tr><tr><td data-num="4"></td><td><pre>通过解析操作，符号引用就可以转变为目标方法在类</pre></td></tr><tr><td data-num="5"></td><td><pre>中方法表中的位置，从而使得方法被成功调用</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">2</span> 小结：</pre></td></tr><tr><td data-num="8"></td><td><pre>所谓解析就是将符号引用转为直接引用，也就是得到类、字段、</pre></td></tr><tr><td data-num="9"></td><td><pre>方法在内存中的指针或者偏移量。因此，可以说，如果</pre></td></tr><tr><td data-num="10"></td><td><pre>直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但</pre></td></tr><tr><td data-num="11"></td><td><pre>只存在符号引用，不能确定系统中一定存在该结构。</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>不过<span class="token class-name">Java</span>虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。</pre></td></tr><tr><td data-num="14"></td><td><pre>在 <span class="token class-name">Hotspot</span> VM中，加载、验证、准备和初始化会</pre></td></tr><tr><td data-num="15"></td><td><pre>按照顺序有条不素地执行，但链接阶段中的解析操作往往会伴随着</pre></td></tr><tr><td data-num="16"></td><td><pre>JVM在执行完初始化之后再执行。</pre></td></tr><tr><td data-num="17"></td><td><pre>字符串的复习</pre></td></tr><tr><td data-num="18"></td><td><pre>最后，再来看一下 CONSTANT_ <span class="token class-name">String</span>的解析。由于字符串在程序</pre></td></tr><tr><td data-num="19"></td><td><pre>开发中有着重要的作用，因此，读者有必要了解一下</pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token class-name">String</span>在<span class="token class-name">Java</span>虚拟机中的处理。当在<span class="token class-name">Java</span>代码中直接使用字符串</pre></td></tr><tr><td data-num="21"></td><td><pre>量时，就会在类中出现 CONSTANT_ <span class="token class-name">String</span><span class="token punctuation">,</span>它表示</pre></td></tr><tr><td data-num="22"></td><td><pre>字符串常量，并且会引用一个 CONSTANT_UTF8的常</pre></td></tr><tr><td data-num="23"></td><td><pre>在<span class="token class-name">Java</span>虚拟行中的常量池中，会维护一张字符串拘留表<span class="token punctuation">(</span> intern<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="24"></td><td><pre>它会保存所有出现过的字符串常量（井且没有重复项。只要以 </pre></td></tr><tr><td data-num="25"></td><td><pre>CONSTANT_ <span class="token class-name">String</span>形式出现的字符串也都会在这张表中。</pre></td></tr><tr><td data-num="26"></td><td><pre>使用 <span class="token class-name">String</span><span class="token punctuation">.</span> intern（）方法可以得到一个字行串在拘留表</pre></td></tr><tr><td data-num="27"></td><td><pre>中的引用，因为该表中没有重复项，所以任</pre></td></tr><tr><td data-num="28"></td><td><pre>何字面相同的字符串的 <span class="token class-name">String</span><span class="token punctuation">.</span>intern（）方法返回总是相等的</pre></td></tr></table></figure><h2 id="初始化阶段"><a class="anchor" href="#初始化阶段">#</a> 初始化阶段</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>简言之，为类的静态变量赋予正确的初始值。</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">1</span> 具体描述</pre></td></tr><tr><td data-num="3"></td><td><pre>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，</pre></td></tr><tr><td data-num="4"></td><td><pre>那么表示类可以顺利装载到系统中。此时，类才会开始执行<span class="token class-name">Java</span>字</pre></td></tr><tr><td data-num="5"></td><td><pre>节码。<span class="token punctuation">(</span>即：到了初始化阶段，才真正开始执行类中定义的<span class="token class-name">Java</span>程序</pre></td></tr><tr><td data-num="6"></td><td><pre>代码。<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>初始化阶段的重要工作是执行类的初始化方法：clinit<span class="token operator">></span>（）方法</pre></td></tr><tr><td data-num="8"></td><td><pre>该方法仅能由java编译器生成并由JVM调用，程序开发者无法自定</pre></td></tr><tr><td data-num="9"></td><td><pre>义一个同名的方法，更无法直接在<span class="token class-name">Java</span>程序中调用该方法，虽然该</pre></td></tr><tr><td data-num="10"></td><td><pre>方法也是由字节码指令所组成</pre></td></tr><tr><td data-num="11"></td><td><pre>它是由类静态成员的赋值语句以及<span class="token keyword">static</span>语句块合并产生的。</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token number">2</span> 说明</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token number">2.1</span> 在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父</pre></td></tr><tr><td data-num="15"></td><td><pre>类的<span class="token generics"><span class="token punctuation">&lt;</span>clinit<span class="token punctuation">></span></span>总是在子类<span class="token generics"><span class="token punctuation">&lt;</span>c1init<span class="token punctuation">></span></span>之前被调用。</pre></td></tr><tr><td data-num="16"></td><td><pre>也就是说，父类的 <span class="token keyword">static</span>块优先级高于子类。</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token number">2.2</span> <span class="token class-name">Java</span>编译器并不会为所有的类都产生<span class="token generics"><span class="token punctuation">&lt;</span> clinit<span class="token punctuation">></span></span>（）初始化方法。</pre></td></tr><tr><td data-num="18"></td><td><pre>哪些类在编译为字节码后，字节码文件中将不会包括clinit<span class="token operator">></span>（）方法？</pre></td></tr><tr><td data-num="19"></td><td><pre>一个类中并没有声明任何的类变量，也没有静态代码块时</pre></td></tr><tr><td data-num="20"></td><td><pre>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及</pre></td></tr><tr><td data-num="21"></td><td><pre>静态代码块来执行初始化操作时</pre></td></tr><tr><td data-num="22"></td><td><pre>一个类中包含 <span class="token keyword">static</span> <span class="token keyword">final</span>修饰的基本数据类型的字段，这些</pre></td></tr><tr><td data-num="23"></td><td><pre>类字段初始化语句采用编译时常量表达式</pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token generics"><span class="token punctuation">&lt;</span> clinit<span class="token punctuation">></span></span><span class="token number">0</span>的线程安全性</pre></td></tr><tr><td data-num="25"></td><td><pre>对于<span class="token generics"><span class="token punctuation">&lt;</span> clinit<span class="token punctuation">></span></span>（）方法的调用，也就是类的初始化，虚拟机会在内</pre></td></tr><tr><td data-num="26"></td><td><pre>部确保其多线程环境中的安全性</pre></td></tr><tr><td data-num="27"></td><td><pre>虚拟机会保证一个类的<span class="token generics"><span class="token punctuation">&lt;</span>clinit<span class="token punctuation">></span></span>（）方法在多线程环境中被正确地</pre></td></tr><tr><td data-num="28"></td><td><pre>加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个</pre></td></tr><tr><td data-num="29"></td><td><pre>线程去执行这个类的<span class="token generics"><span class="token punctuation">&lt;</span>clinit<span class="token punctuation">></span></span>（）方法，其他线程都需要阻塞等待，</pre></td></tr><tr><td data-num="30"></td><td><pre>直到活动线程执行<span class="token generics"><span class="token punctuation">&lt;</span>c1init<span class="token punctuation">></span></span>（）方法完毕。</pre></td></tr><tr><td data-num="31"></td><td><pre>正是因为函数<span class="token generics"><span class="token punctuation">&lt;</span>clinit<span class="token punctuation">></span></span>（）帯锁线程安全的，因此，如果在一个类</pre></td></tr><tr><td data-num="32"></td><td><pre>的<span class="token generics"><span class="token punctuation">&lt;</span>clinit<span class="token punctuation">></span></span>（）方法中有耗时很长的操作，就可能造成多</pre></td></tr><tr><td data-num="33"></td><td><pre>个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为</pre></td></tr><tr><td data-num="34"></td><td><pre>看起来它们并没有可用的锁信息。</pre></td></tr><tr><td data-num="35"></td><td><pre>如果之前的线程成功加载了类，则等在队列中的线程就没有机会</pre></td></tr><tr><td data-num="36"></td><td><pre>再执行<span class="token generics"><span class="token punctuation">&lt;</span>clinit<span class="token punctuation">></span></span>（）方法了。那么，当需要使用这个类时<span class="token punctuation">,</span>虚拟机</pre></td></tr><tr><td data-num="37"></td><td><pre>会直接返回给它己经准备好的信息。</pre></td></tr></table></figure><blockquote><h2 id="初始化阶段赋值与准备阶段赋值"><a class="anchor" href="#初始化阶段赋值与准备阶段赋值">#</a> 初始化阶段赋值与准备阶段赋值</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 在初始化阶段 & lt;clinit > 中赋值</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INT_CONSTANT<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 链接阶段的准备环节</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> INTEGER_CONSTANT1<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment">// 在初始化阶段 & lt;clinit > 中赋值</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> INTEGER_CONSTANT2<span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 在初始化阶段 & lt;clinit > 中赋值</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> s0<span class="token operator">=</span><span class="token string">"hello1"</span><span class="token punctuation">;</span>  <span class="token comment">// 链接阶段的准备环节</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> s1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在初始化阶段 & lt;clinit > 中赋值</span></pre></td></tr></table></figure><p><mark>结论</mark>：</p><p>使用 static+final 修饰，且显式赋值中不涉及到方法或构造器调用的基本数据类型或 String 类型的显式赋值，是在链接阶段准备环节进行的。</p><blockquote><h2 id="主动使用"><a class="anchor" href="#主动使用">#</a> 主动使用</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Class</span>只有在必须要首次使用的时候才会被装载，<span class="token class-name">Java</span>虚拟机</pre></td></tr><tr><td data-num="2"></td><td><pre>不会无条件地装载<span class="token class-name">Class</span>类型。<span class="token class-name">Java</span>虚拟机规定，一个类或</pre></td></tr><tr><td data-num="3"></td><td><pre>接口在初次使用前，必须要进行初始化。这里指的“使用”，是指</pre></td></tr><tr><td data-num="4"></td><td><pre>主动使用，主动使用只有下列几种情况：（即：如果出现如</pre></td></tr><tr><td data-num="5"></td><td><pre>下的情况，则会对类进行初始化操作。而初始化操作之前的</pre></td></tr><tr><td data-num="6"></td><td><pre>加载、验证、准备己经完成。）</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">1</span> 当创建一个类的实例时，比如使用<span class="token keyword">new</span>关键字，或者通过</pre></td></tr><tr><td data-num="9"></td><td><pre>反射、克隆、反序列化。</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">2</span> 当调用类的静态方法时，即当使用了字节码 invokestatic指令</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token number">3</span> 当使用类、接口的静态字段时<span class="token punctuation">(</span>fina修饰特殊考虑<span class="token punctuation">)</span>，比如，</pre></td></tr><tr><td data-num="12"></td><td><pre>使用 getstatic或者 putstatic指令。（对应访问变量、</pre></td></tr><tr><td data-num="13"></td><td><pre>赋值变量操作）</pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token number">4</span> 当使用java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span> reflect包中的方法反射类的方法时。</pre></td></tr><tr><td data-num="15"></td><td><pre>比如：<span class="token class-name">Class</span><span class="token punctuation">.</span> <span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com. atgulgu.java.Test"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token number">5</span> 当初始化子类时，如果发现其父类还没有进行过初始化，</pre></td></tr><tr><td data-num="17"></td><td><pre>则需要先触发其父类的初始化。</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token number">6</span> 如果一个接口定义了 <span class="token keyword">default</span>方法，那么直接实现或者间接实现该</pre></td></tr><tr><td data-num="19"></td><td><pre>接口的类的初始化，该接口要在其之前被初始化</pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token number">7</span> 当虚拟机启动时，用户需要指定一个要执行的主类<span class="token punctuation">(</span>包含main（）方</pre></td></tr><tr><td data-num="21"></td><td><pre>法的那个类），虚拟机会先初始化这个主类。</pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token number">8</span> 当初次调用 <span class="token class-name">Methodhandle</span>实例时，初始化该 <span class="token class-name">Methodhandle</span>指</pre></td></tr><tr><td data-num="23"></td><td><pre>向的方法所在的类。（涉及解析</pre></td></tr><tr><td data-num="24"></td><td><pre>REF_ getstatic、REF_ putstatic、REF_ invokestatic</pre></td></tr><tr><td data-num="25"></td><td><pre>方法句柄对应的类）</pre></td></tr><tr><td data-num="26"></td><td><pre>                         </pre></td></tr><tr><td data-num="27"></td><td><pre>对<span class="token number">5</span><span class="token punctuation">,</span>补充说明</pre></td></tr><tr><td data-num="28"></td><td><pre>当<span class="token class-name">Java</span>虚拟机初始化一个类时，要求它的所有父类都已经被</pre></td></tr><tr><td data-num="29"></td><td><pre>初始化，但是这条规则并不适用于接口。</pre></td></tr><tr><td data-num="30"></td><td><pre>在初始化一个类时，并不会先初始化它所实现的接口</pre></td></tr></table></figure><blockquote><h2 id="被动使用"><a class="anchor" href="#被动使用">#</a> 被动使用</h2></blockquote><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>除了以上的情况属于主动使用，其他的情况均属于被动使用。</pre></td></tr><tr><td data-num="2"></td><td><pre>被动使用不会引起类的初始化。</pre></td></tr><tr><td data-num="3"></td><td><pre>也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。</pre></td></tr><tr><td data-num="4"></td><td><pre>如果不符合主如动使用的条件，类就不会初始</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">1</span> 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。</pre></td></tr><tr><td data-num="6"></td><td><pre>当通过子类引用父类的静态变量，不会导致子类初始化</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">2</span> 通过数组定义类引用，不会触发此类的初始化</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token number">3</span> 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就</pre></td></tr><tr><td data-num="9"></td><td><pre>己经被显式赋值了。</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token number">4</span> 调用classloader类的loadClass（）方法加载一个类<span class="token punctuation">,</span>并不是对类的主动使用，不会导致类的初始化。</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token number">5.</span>类对象<span class="token punctuation">.</span><span class="token keyword">class</span>不会触发初始化</pre></td></tr></table></figure><h1 id="类的卸载"><a class="anchor" href="#类的卸载">#</a> 类的卸载</h1><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>类、类的加载器、类的实例之间的引用关系</pre></td></tr><tr><td data-num="2"></td><td><pre>在类加载器的内部实现中，用一个<span class="token class-name">Java</span>集合来存放所加载类的引用。</pre></td></tr><tr><td data-num="3"></td><td><pre>另一方面，一个<span class="token class-name">Class</span>对象总是会引用它的类加载器</pre></td></tr><tr><td data-num="4"></td><td><pre>调用<span class="token class-name">Class</span>对象的 getclassloader（）方法，就能获得它的类加</pre></td></tr><tr><td data-num="5"></td><td><pre>载器。由此可见，代表某个类的<span class="token class-name">Class</span>实例与其类的加</pre></td></tr><tr><td data-num="6"></td><td><pre>载器之间为双向关联关系。</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>一个类的实例总是引用代表这个类的<span class="token class-name">Class</span>对象。在 <span class="token class-name">Object</span><span class="token operator">:</span>类中定</pre></td></tr><tr><td data-num="9"></td><td><pre>义了getclass（）方法，这个方法返回代表对象所属类</pre></td></tr><tr><td data-num="10"></td><td><pre>的<span class="token class-name">Class</span>对象的引用。此外，所有的<span class="token class-name">Java</span>类都有一个静态属</pre></td></tr><tr><td data-num="11"></td><td><pre>性<span class="token keyword">class</span><span class="token punctuation">,</span>它引用代表这个类的<span class="token class-name">Class</span>对象。</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>类的生命周期</pre></td></tr><tr><td data-num="14"></td><td><pre>当 <span class="token class-name">Sample</span>类被加载、链接和初始化后，它的生命周期就开始了。</pre></td></tr><tr><td data-num="15"></td><td><pre>当代表<span class="token class-name">Sample</span>类的<span class="token class-name">Class</span>对象不再被引用，即不可触及</pre></td></tr><tr><td data-num="16"></td><td><pre>时，<span class="token class-name">Class</span>对象就会结東生命周期， <span class="token class-name">Sample</span>类在方法区内的</pre></td></tr><tr><td data-num="17"></td><td><pre>数据也会被卸载，从而结束 <span class="token class-name">Sample</span>类的生命周期。</pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>一个类何时结東生命周期，取决于代表它的<span class="token class-name">Class</span>对象何时</pre></td></tr><tr><td data-num="20"></td><td><pre>结束生命周期。</pre></td></tr></table></figure><p><img data-src="https://tva1.sinaimg.cn/large/008i3skNgy1guezaeo9sgj61340l4mzc02.jpg" alt="image-20210913142127564"></p><figure class="highlight markdown"><figcaption data-lang="markdown"></figcaption><table><tr><td data-num="1"></td><td><pre>(1)启动类加载器加载的类型在整个运行期间是不可能被卸</pre></td></tr><tr><td data-num="2"></td><td><pre>载的(jvm和jls规范)</pre></td></tr><tr><td data-num="3"></td><td><pre>(2)被系统类加载器和扩展类加载器加载的类型在运行期间不太可</pre></td></tr><tr><td data-num="4"></td><td><pre>能被卸载，因为系类加器实例或者扩展类的实例基本上在整个运行</pre></td></tr><tr><td data-num="5"></td><td><pre>期间总能直接或者间接的访问的到，其达到 unreachable的可</pre></td></tr><tr><td data-num="6"></td><td><pre>能性极小。</pre></td></tr><tr><td data-num="7"></td><td><pre>(3)被开发者自定义的类加载器实例加载的类型只有在很简单的上</pre></td></tr><tr><td data-num="8"></td><td><pre>下文环境中才能被卸载，而且一般还要借助于强制调用</pre></td></tr><tr><td data-num="9"></td><td><pre>虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应</pre></td></tr><tr><td data-num="10"></td><td><pre>用场景中（比如：很多时候用户在开发自定义类加载器实</pre></td></tr><tr><td data-num="11"></td><td><pre>例的时候采用缓存的策略以提高系统性能），被加载的类型在运行</pre></td></tr><tr><td data-num="12"></td><td><pre>期间也是几乎不太可能被卸载的（至少卸载的时间是不确</pre></td></tr><tr><td data-num="13"></td><td><pre>定的）。</pre></td></tr><tr><td data-num="14"></td><td><pre>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载</pre></td></tr><tr><td data-num="15"></td><td><pre>的时间是不确定的。同时我们可以看的出来，开发者在</pre></td></tr><tr><td data-num="16"></td><td><pre>开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，</pre></td></tr><tr><td data-num="17"></td><td><pre>来实现系统中的特定功能。</pre></td></tr></table></figure><div class="tags"><a href="/tags/jvm/" rel="tag"><i class="ic i-tag"></i> jvm</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-10-21 20:17:52" itemprop="dateModified" datetime="2021-10-21T20:17:52+08:00">2021-10-21</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>故犹 <i class="ic i-at"><em>@</em></i>努力走,走到灯火通明</li><li class="link"><strong>本文链接：</strong> <a href="https://guyouwyh.github.io/guyouwyh/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm8/" title="JVM笔记(八)-类加载的三个阶段">https://guyouwyh.github.io/guyouwyh/2021/10/21/后端/Java/jvm8/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm7/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2021&#x2F;12&#x2F;15&#x2F;IJoXjhzGPOQdi9c.jpg" title="JVM笔记(七)-字节码指令"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础</span><h3>JVM笔记(七)-字节码指令</h3></a></div><div class="item right"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/ORM%E6%A1%86%E6%9E%B6/MyBatis/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2021&#x2F;12&#x2F;15&#x2F;fV3IslvSQ86qJpj.jpg" title="Mybatis笔记"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> ORM框架</span><h3>Mybatis笔记</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8java%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E4%B8%BA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE-%E7%B1%BB%E5%9E%8B%E7%94%B1%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A2%84%E5%85%88%E5%AE%9A%E4%B9%89%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%99%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E6%8C%89%E7%85%A7java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E4%BB%8Eclass%E6%96%87%E4%BB%B6%E5%88%B0%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%88%B0-%E7%B1%BB%E5%8D%B8%E8%BD%BD%E5%87%BA%E5%86%85%E5%AD%98%E4%B8%BA%E6%AD%A2%E5%AE%83%E7%9A%84%E6%95%B4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8C%85%E6%8B%AC%E5%A6%82%E4%B8%8B7%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">1.1.</span> <span class="toc-text">在 Java 中数据类型分为基本数据类型和引用数据类型。基本数据 类型由虚拟机预先定义，引用数据类型则需要进行类的加载 按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到 类卸载出内存为止，它的整个生命周期包括如下 7 个阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.</span> <span class="toc-text">加载阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">二进制流的获取方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B8%8Eclass%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.</span> <span class="toc-text">类模型与 Class 实例的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.5.</span> <span class="toc-text">数组类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">1.6.</span> <span class="toc-text">链接阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5verification"><span class="toc-number">1.7.</span> <span class="toc-text">验证阶段 (Verification)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-number">1.8.</span> <span class="toc-text">准备阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5"><span class="toc-number">1.9.</span> <span class="toc-text">解析阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">1.10.</span> <span class="toc-text">初始化阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E8%B5%8B%E5%80%BC%E4%B8%8E%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E8%B5%8B%E5%80%BC"><span class="toc-number">1.11.</span> <span class="toc-text">初始化阶段赋值与准备阶段赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.12.</span> <span class="toc-text">主动使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">1.13.</span> <span class="toc-text">被动使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.</span> <span class="toc-text">类的卸载</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%80)/" rel="bookmark" title="Java面向对象(一)">Java面向对象(一)</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%BA%8C)/" rel="bookmark" title="Java面向对象(二)">Java面向对象(二)</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/IO%E6%B5%81/" rel="bookmark" title="JavaIO流">JavaIO流</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/%E5%8F%8D%E5%B0%84/" rel="bookmark" title="Java反射">Java反射</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" rel="bookmark" title="Java8新特性">Java8新特性</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" rel="bookmark" title="Java异常处理">Java异常处理</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="bookmark" title="Java的常用类">Java的常用类</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm1/" rel="bookmark" title="JVM笔记(一)-概述">JVM笔记(一)-概述</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm2/" rel="bookmark" title="JVM笔记(二)-类加载器">JVM笔记(二)-类加载器</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm3/" rel="bookmark" title="JVM笔记(三)-运行时数据区">JVM笔记(三)-运行时数据区</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm4/" rel="bookmark" title="JVM笔记(四)-执行引擎">JVM笔记(四)-执行引擎</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm5/" rel="bookmark" title="JVM笔记(五)-字符串常量池">JVM笔记(五)-字符串常量池</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm6/" rel="bookmark" title="JVM笔记(六)-垃圾回收">JVM笔记(六)-垃圾回收</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm7/" rel="bookmark" title="JVM笔记(七)-字节码指令">JVM笔记(七)-字节码指令</a></li><li class="active"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm8/" rel="bookmark" title="JVM笔记(八)-类加载的三个阶段">JVM笔记(八)-类加载的三个阶段</a></li><li><a href="/2021/10/23/%E5%90%8E%E7%AB%AF/Java/Java%E6%B3%A8%E8%A7%A3/" rel="bookmark" title="Java注解">Java注解</a></li><li><a href="/2021/10/23/%E5%90%8E%E7%AB%AF/Java/Java%E6%9E%9A%E4%B8%BE/" rel="bookmark" title="Java枚举">Java枚举</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="故犹" data-src="/images/avatar.jpg"><p class="name" itemprop="name">故犹</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">192</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">36</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">92</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1eW91d3lo" title="https:&#x2F;&#x2F;github.com&#x2F;guyouwyh"><i class="ic i-github"></i></span> <a href="/821403296@qq.com" title="821403296@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-link"></i>友链</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-magic"></i>常用网站</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm7/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/ORM%E6%A1%86%E6%9E%B6/MyBatis/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/2021/11/06/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/" title="【力扣】322.零钱兑换">【力扣】322.零钱兑换</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/" title="分类于 模拟">模拟</a></div><span><a href="/2022/01/08/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3%E5%B0%8FScarlet/" title="【洛谷】P4924 [1007]魔法少女小Scarlet">【洛谷】P4924 [1007]魔法少女小Scarlet</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/" title="分类于 模拟">模拟</a></div><span><a href="/2022/03/29/%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/" title="【牛客】JZ75 字符流中第一个不重复的字符">【牛客】JZ75 字符流中第一个不重复的字符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/2022/04/06/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/" title="【力扣】416. 分割等和子集">【力扣】416. 分割等和子集</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="分类于 Java并发编程">Java并发编程</a></div><span><a href="/2021/10/29/%E5%90%8E%E7%AB%AF/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E5%AE%89%E5%85%A8/" title="JUC(二)线程的状态和安全">JUC(二)线程的状态和安全</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="分类于 并查集">并查集</a></div><span><a href="/2022/04/03/%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86/547.%20%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F/" title="【力扣】省份数量">【力扣】省份数量</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java基础">Java基础</a></div><span><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm8/" title="JVM笔记(八)-类加载的三个阶段">JVM笔记(八)-类加载的三个阶段</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/" title="分类于 搜索">搜索</a></div><span><a href="/2021/10/29/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/" title="【力扣】869.重新排序得到2的幂">【力扣】869.重新排序得到2的幂</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/" title="分类于 搜索">搜索</a></div><span><a href="/2022/03/29/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/JZ37%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/" title="【牛客】JZ37 序列化二叉树">【牛客】JZ37 序列化二叉树</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Spring%E6%A1%86%E6%9E%B6/" title="分类于 Spring框架">Spring框架</a></div><span><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Spring%E6%A1%86%E6%9E%B6/SpringMVC3/" title="SpringMCV(三)">SpringMCV(三)</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">故犹 @ GuYou</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">562k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">8:31</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/10/21/后端/Java/jvm8/",favicon:{show:"加载中",hide:"OvO"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->