<!-- build time:Sun Mar 20 2022 10:45:14 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><link rel="mask-icon" href="/images/logo.svg" color=""><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/rss.xml"><link rel="alternate" type="application/atom+xml" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/atom.xml"><link rel="alternate" type="application/json" title="努力走,走到灯火通明" href="https://guyouwyh.github.io/guyouwyh/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="jvm"><link rel="canonical" href="https://guyouwyh.github.io/guyouwyh/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm6/"><title>JVM笔记(六)-垃圾回收 - Java基础 - 后端 | GuYou = 努力走,走到灯火通明</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JVM笔记(六)-垃圾回收</h1><div class="meta"><span class="item" title="创建时间：2021-10-21 20:14:40"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-10-21T20:14:40+08:00">2021-10-21</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>10k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>9 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">GuYou</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2021/12/15/nQSr6Dxua7pIvlB.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/fqp9bDFPBEIHCz5.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/B735tDMiU2eZFjK.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/sE4YZtNxHrPTG8c.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/7E2sYl8uZARyLqh.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2021/12/15/8KdoJ6jO7mLCDUu.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="item" rel="index" title="分类于 后端"><span itemprop="name">后端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%90%8E%E7%AB%AF/Java/" itemprop="item" rel="index" title="分类于 Java基础"><span itemprop="name">Java基础</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://guyouwyh.github.io/guyouwyh/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="故犹"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="努力走,走到灯火通明"></span><div class="body md" itemprop="articleBody"><h1 id="gc"><a class="anchor" href="#gc">#</a> GC</h1><blockquote><h2 id="什么是垃圾garbage"><a class="anchor" href="#什么是垃圾garbage">#</a> 什么是垃圾 (Garbage)?</h2></blockquote><p><strong>垃圾是指在运行程序中没有任何指针指向的对象。</strong></p><p>如果不及时对内存中的垃圾进行清理，那么这些垃圾对象所占的内存空间会一致保留到应用程序结束，被保留的空间无法被其他对象所利用，甚至可能导致内存溢出</p><h2 id="垃圾标记阶段"><a class="anchor" href="#垃圾标记阶段">#</a> 垃圾标记阶段</h2><blockquote><h2 id="垃圾标记阶段对象存活判断"><a class="anchor" href="#垃圾标记阶段对象存活判断">#</a> 垃圾标记阶段：对象存活判断</h2></blockquote><ul><li><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p></li><li><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡了</p></li><li><p>判断对象存活一般有两种方式：引用计数算法和可达性分析算法</p></li></ul><h3 id="引用计数算法"><a class="anchor" href="#引用计数算法">#</a> 引用计数算法</h3><blockquote><h2 id="概述"><a class="anchor" href="#概述">#</a> 概述</h2></blockquote><p>引用计数算法比较简单，对每一个对象保存一个整型的引用计数器属性，用于记录对象呗引用的情况</p><p>对于一个对象 A, 只要有任何一个对象引用了 A, 则 A 的引用计数器就加 1, 当引用失效时，引用计数器就减 1, 只要对象 A 的引用计数器的值为 0, 即表示对象 A 不可能再被使用，可以进行回收</p><p>优点：实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性</p><p>缺点:</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销</li><li>引用计数器有一个严重的问题，即无法处理循环引用的情况。导致在 Java 的垃圾回收器中没有使用这种算法。</li></ul><h3 id="可达性分析算法"><a class="anchor" href="#可达性分析算法">#</a> 可达性分析算法</h3><ul><li><p>相较于引用计数器算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用问题，防止内存泄露的发生。</p></li><li><p>相较于引用计数算法，这里的可达性分析就是 Java、C# 的选择，这种类型的垃圾回收通常也叫做追踪性垃圾收集。</p></li></ul><blockquote><h2 id="基本思路"><a class="anchor" href="#基本思路">#</a> 基本思路</h2></blockquote><ul><li>可达性分析算法是以根对象集合 (GC Roots) 为起始点，根据从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链 (Reference Chain)</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象</li></ul><blockquote><h2 id="gc-roots"><a class="anchor" href="#gc-roots">#</a> GC Roots</h2></blockquote><ul><li><p>虚拟机栈中引用的对象</p></li><li><p>本地方法栈内 JNT (本地方法) 引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法去中常量引用的对象 (字符串常量池里的引用)</p></li><li><p>所有被同步锁 synchronized 持有的对象</p></li><li><p>Java 虚拟机内部的引用 (基本数据类型对应的 Class 对象，一些常驻的异常对象), 系统类加载器。</p><p>小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里，那么他就是一个 Root。</p></li></ul><blockquote><h2 id="finalization机制"><a class="anchor" href="#finalization机制">#</a> finalization 机制</h2></blockquote><ul><li><p>Java 语言提供了对象终止 (finalization) 机制允许开发人员提供对象呗销毁之前的自定义处理逻辑</p></li><li><p>当垃圾回收期发现没有引用指向一个对象，即垃圾回收此对象之前，总会先调用这个对象 finalize () 方法</p></li><li><p>finalize () 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常这个方法中进行一些资源释放和清理工作，比如关闭文件、套接字和数据库连接等。</p></li><li><p>永远不要主动调用某个对象的 finalize () 方法，应该交给垃圾回收机制调用，理由如下:</p><ul><li>在 finalize () 时可能会导致对象复活</li><li>finalize () 方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC, 则 finalize () 方法将没有执行机会</li><li>一个糟糕的 finalize () 会严重影响 GC 的性能</li></ul></li><li><p>由于 finalize () 方法的存在，虚拟机中对象存在有三种状态</p><ul><li>可触及的：从根节点开始，可以到达这个对象</li><li>可复活的：对象的所有引用都被释放，但是对象可能在 finalize () 中复活</li><li>不可触及的：对象的 finalize () 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize () 只会被调用一次</li></ul></li></ul><h2 id="垃圾清除阶段"><a class="anchor" href="#垃圾清除阶段">#</a> 垃圾清除阶段</h2><p>当成功区分出内存中存活的对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用	对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存</p><p>目前 JVM 中比较常见的三种垃圾收集算法是标记 - 清除算法 (Mark-Sweep)、复制算法 (Copying)、标记 - 压缩算法 (Mark - Compact)</p><h3 id="标记-清除mark-sweep算法"><a class="anchor" href="#标记-清除mark-sweep算法">#</a> 标记 - 清除 (Mark-Sweep) 算法</h3><p>当堆中的有效空间被耗尽的时候，就会停止整个程序，然后进行两项工作，第一项则是标记，第二项则是消除</p><ul><li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象</li><li>清除：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中咩有标记为可达对象，则将其进行回收。</li></ul><h3 id="复制算法copying"><a class="anchor" href="#复制算法copying">#</a> 复制算法 (Copying)</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><blockquote><h2 id="优点"><a class="anchor" href="#优点">#</a> 优点</h2></blockquote><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现 &quot;碎片&quot; 问题</li></ul><blockquote><h2 id="缺点"><a class="anchor" href="#缺点">#</a> 缺点</h2></blockquote><ul><li>此算法的缺点也是很明显，就是需要两倍的内存空间</li><li>对于 G1 这种分拆成大量的 region 的 GC, 复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</li><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大或者说非常低才行</li></ul><h3 id="标记-压缩mark-compact算法"><a class="anchor" href="#标记-压缩mark-compact算法">#</a> 标记 - 压缩 (Mark-Compact) 算法</h3><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有存活的对象压缩到内存的一端，按顺序排放，之后清理边界外所有空间</p><p>标记 - 压缩算法的最终效果等同于标记 - 清除算法执行完成后，在进行内存碎片的处理。</p><blockquote><h2 id="优点-2"><a class="anchor" href="#优点-2">#</a> 优点</h2></blockquote><ul><li>消除了标记 - 清除算法中，内存区域分散的特点，我们需要给新对象分配内存时候，JVM 只需要持有一个内存起始地址即可</li><li>消除了复制算法中，内存减半的高额代价</li></ul><blockquote><h3 id="缺点-2"><a class="anchor" href="#缺点-2">#</a> 缺点</h3></blockquote><ul><li>从效率上来说，标记 - 整理算法要低于复制算法</li><li>移动对象的同事，如果对象被其他对象引用，则还需要调整引用的的地址</li><li>移动过程中，需要全程暂停用户应用程序，即 STW (stop the world)</li></ul><h2 id="分代收集算法"><a class="anchor" href="#分代收集算法">#</a> 分代收集算法</h2><p>分代收集算法是基于这样一个事实：不同的对象的生命周期是不一样的，因此，不同声明周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 http 请求中的 Session 对象 / 线程、socket 连接，这类对象跟业务直接挂钩，因此生命周期较长，但还是会有一些对象，主要是程序中生成的临时变量，这些对象声明周期较短。有些对象甚至只用一次即可回收</p><ul><li>年轻代</li></ul><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低、回收频繁，这种情况适合使用复制算法。</p><ul><li>老年代</li></ul><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁，一般由标记 - 清除算法和标记 - 压缩算法混合实现。</p><blockquote><h2 id="过程"><a class="anchor" href="#过程">#</a> 过程</h2></blockquote><ol><li><p>对象首先分配在伊甸园区</p></li><li><p>新生代空间不足的时候，会触发 minor GC, 伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄 + 1 并且交换 from to</p></li><li><p>minor gc 会引发 stop the world, 暂停其他用户的线程，等垃圾回收结束，用户线程恢复运行</p></li><li><p>当对象寿命超过阈值时，会晋升为老年代，最大的寿命为 15 (4bit)</p></li><li><p>当老年代空间不足，会先尝试触发 minorGC, 如果之后空间仍不足，就会触发 fullGC</p></li></ol><h2 id="增量收集算法"><a class="anchor" href="#增量收集算法">#</a> 增量收集算法</h2><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行，每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><h2 id="systemgc"><a class="anchor" href="#systemgc">#</a> System.gc()</h2><p>在默认情况下，通过 System.gc () 或者 Runtime.getRuntime.gc () 的调用，会显示触发 Full GC, 同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。但是不确定垃圾回收会马上执行。</p><h2 id="内存溢出oom"><a class="anchor" href="#内存溢出oom">#</a> 内存溢出 (OOM)</h2><p>没有空闲内存，并且垃圾收集齐也无法提供更多内存。</p><blockquote><h2 id="没有空闲内存的情况"><a class="anchor" href="#没有空闲内存的情况">#</a> 没有空闲内存的情况</h2></blockquote><ol><li>Java 虚拟机的堆内存设置不够</li></ol><p>比如：可能存在内存泄露问题，也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显示指定 JVM 堆大小或者指定数值偏小，我们可以通过 - Xms、-Xmx 来调整</p><ol start="2"><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集</li></ol><h2 id="内存泄露memory-leak"><a class="anchor" href="#内存泄露memory-leak">#</a> 内存泄露 (Memory Leak)</h2><p>也称作 &quot;存储渗漏&quot;, 严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏</p><p>但是实际情况很都时候一些不太友好的实践会导致对象的生命周期变得很长导致 OOM, 也可以叫做宽泛意义上的内存泄漏</p><h2 id="stop-the-world"><a class="anchor" href="#stop-the-world">#</a> Stop The World</h2><p>简称 STW, 指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应</p><p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要介绍 STW 的发生</p><h2 id="垃圾回收的并发与并行"><a class="anchor" href="#垃圾回收的并发与并行">#</a> 垃圾回收的并发与并行</h2><p>并行 (Paraller): 指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态.</p><p>串行 (Serial): 相较于并行概念，单线程执行，如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行回收，回收完再启动程序的线程</p><h2 id="安全点"><a class="anchor" href="#安全点">#</a> 安全点</h2><p>程序在执行时并非在所有地方都能停顿下来开始 GC, 只有在特定的位置才能停顿下来 GC, 这些位置称为 &quot;安全点 (Safepoint)&quot;.</p><p>SafePoint 的选择很重要，如果太少可能导致 GC 等待时间太长，如果太频繁可能导致运行时的性能问题，大部分的指令的执行时间都非常短暂，通常会根据 &quot;是否具有让程序长时间执行的特征&quot; 为标准，比如选择一些执行时间较长的命令作为 Safe Point, 如方法调用、循环跳转和异常跳转等。</p><h2 id="安全区域safe-region"><a class="anchor" href="#安全区域safe-region">#</a> 安全区域 (Safe Region)</h2><p>SafePoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 SafePoint. 但是程序不执行的时候例如线程处于 sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，走到安全点去中断挂起，JVM 也不太可能等待线程被唤醒，对于这种情况，就需要安全区域 (Safe Region) 来解决</p><p><mark>安全区域是指一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。</mark></p><h2 id="引用"><a class="anchor" href="#引用">#</a> 引用</h2><p>在 jdk1.2 改版之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference)、软引用 (Soft Reference)、弱引用 (Weak Reference) 和虚引用 (Phantom Reference) 四种，这四种引用强度依次减弱</p><blockquote><h2 id="强引用strongreference"><a class="anchor" href="#强引用strongreference">#</a> 强引用 (StrongReference)</h2></blockquote><p>最传统的引用定义，是指在程序代码之中普遍存在的引用赋值。即类似于 &quot;Object object =new Object ()&quot; 这种引用关系，无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象</p><blockquote><h2 id="软引用softreference-内存不足回收"><a class="anchor" href="#软引用softreference-内存不足回收">#</a> 软引用 (SoftReference)- 内存不足回收</h2></blockquote><p>在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常</p><blockquote><h2 id="弱引用weakreference-发现才回收"><a class="anchor" href="#弱引用weakreference-发现才回收">#</a> 弱引用 (WeakReference)- 发现才回收</h2></blockquote><p>被弱引用关联的对象只能生存到下一次垃圾收集之前，当垃圾收集器工作时，无论内存空间是否足够，都会回收掉弱引用关联的对象。</p><blockquote><h2 id="虚引用phantomreference-对象引用跟踪"><a class="anchor" href="#虚引用phantomreference-对象引用跟踪">#</a> 虚引用 (PhantomReference)- 对象引用跟踪</h2></blockquote><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象收集器收集时候收到一个系统通知</p><p>例如 ByteBuffer 对象被回收的时候，虚引用对象 Cleaner 就会进入一个引用队列，所在的引用队列会由一个叫做 referenceHandle 的线程来定时的到引用队列里找，有没有新入队的 Cleaner, 如果有，就会使用 Unsafe 的 freeMemory 方法，将直接内存给释放掉，保证不会造成直接内存导致的内存泄漏</p><blockquote><h2 id="终结器引用final-reference"><a class="anchor" href="#终结器引用final-reference">#</a> 终结器引用 (Final reference)</h2></blockquote><p>在 GC 时，终结器引用入队，由优先级很低的线程 finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize () 方法，第二次 GC 时候才能回收被引用对象.</p><h2 id="垃圾回收的分类"><a class="anchor" href="#垃圾回收的分类">#</a> 垃圾回收的分类</h2><ul><li>按工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器</li><li>按碎片处理方式分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器</li><li>按工作的内存区间分，又可以分为年轻代垃圾回收器和老年代垃圾回收器</li></ul><h2 id="性能指标"><a class="anchor" href="#性能指标">#</a> 性能指标</h2><ul><li><strong>吞吐量：运行用户代码的时间占总运行时间的比例 (总运行时间 = 程序的运行时间 + 内存回收的时间)</strong></li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li><li><strong>暂停时间：执行垃圾回收时，程序的工作线程被暂停的时间</strong></li><li>收集频率：相对于应用程序的执行，收集操作发生的频率</li><li><strong>内存占用：Java 堆区所占内存大小</strong></li><li>快速：一个对象从诞生到被回收所经历的时间</li></ul><p>吞吐量、暂停时间、内存占用，这三者共同构成了一个 &quot;不可能三角&quot;。三者的总体表现会随着技术进步而越来越好，一款优秀的收集器通常最多满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显，因为随着硬件的发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量，而内存的扩大，对延迟反而带来负面效果。</p><h2 id="七种经典垃圾收集器"><a class="anchor" href="#七种经典垃圾收集器">#</a> 七种经典垃圾收集器</h2><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parellel Scavenge、Parallel Old</li><li>并发回收器：CMS、G1</li></ul><p>根据回收区域不同，又可以分为:</p><ul><li>新生代收集器：Serial、ParNew、Parallel Scavenge</li><li>老年代收集器：Serial Old、Parallel Old、CMS</li><li>整堆收集器：G1</li></ul><blockquote><h2 id="查看默认的垃圾收集器"><a class="anchor" href="#查看默认的垃圾收集器">#</a> 查看默认的垃圾收集器</h2></blockquote><ul><li><strong>-XX:PrintCommandLineFlags</strong>: 查看命令行相关参数 (包括使用的垃圾收集器)</li><li>使用命令行指令:<strong>jinfo -flag 相关垃圾回收器参数 进程 ID</strong></li></ul><h3 id="serial回收器串行回收"><a class="anchor" href="#serial回收器串行回收">#</a> Serial 回收器：串行回收</h3><ul><li>Serial 收集器是最基本、历史最悠久的垃圾收集器.jdk1.3 之前回收新生代的唯一选择。</li><li>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。</li><li>Serial 收集器采用复制算法、串行回收和 STW 机制的方式执行内存回收</li><li>Serial Old 执行老年代垃圾回收，只不过内存回收算法使用标记压缩算法。</li><li>Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器</li><li>Serial Old 在 Server 模式下主要有两个用途:<ul><li>与新生代的 Parallel Scavenge 配合使用</li><li>作为老年代 CMS 收集器的后备收集方案</li></ul></li></ul><blockquote><h4 id="总结"><a class="anchor" href="#总结">#</a> 总结</h4></blockquote><p>只有单核 cpu 才能用，对于交互较强的应用而言，这种垃圾收集器是不能接受的，一般	在 Java Web 应用程序中是不会采用串行垃圾收集器的</p><h3 id="parnew回收器并行回收"><a class="anchor" href="#parnew回收器并行回收">#</a> ParNew 回收器：并行回收</h3><p>如果收 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本</p><p>注意：Par 是 Parallel 的缩写，New: 指能处理的是新生代</p><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾回收器之间几乎没有任何区别。</p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器</p><h3 id="parallel-scavenge回收器吞吐量优先"><a class="anchor" href="#parallel-scavenge回收器吞吐量优先">#</a> Parallel Scavenge 回收器：吞吐量优先</h3><ul><li>Parallel Scavenge 收集器同样采用了复制算法、并行回收和 STW</li><li>与 ParNew 收集器不同，Parallel Scanvenge 收集器的目标是达到一个可控制的吞吐量，它也被称为吞吐量优先的垃圾收集器</li><li>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错</li><li>在 JDK8 中，默认是此垃圾回收器</li></ul><blockquote><h1 id="参数配置"><a class="anchor" href="#参数配置">#</a> 参数配置</h1></blockquote><ul><li>-XX:+UsereParallelGC: 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务</li><li>-XX:+UserParallelOldGC: 手动指定老年代都是使用并行回收收集器<ul><li>分别适用于新生代和老年代，默认 JDK8 是开启的</li><li>默认开启一个，另一个也会开启</li></ul></li></ul><h3 id="cms回收器低延迟"><a class="anchor" href="#cms回收器低延迟">#</a> CMS 回收器：低延迟</h3><ul><li><p>在 JDK1.5 时，HotSpot 推出了一款在强交互应用中几乎具有划时代意义的垃圾收集器：CMS (Concurrent-Mark-Sweep) 收集器，这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p></li><li><p>CMS 收集器的关注点是尽可能缩短垃圾回收时用户线程的停顿时间，停顿时间越短就约适合与用户交互的程序，良好的相应速度能提升用户的体验</p></li><li><p>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的相应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求</p></li><li><p>CMS 的垃圾收集算法采用标记 - 清除算法，并且也会 STW</p></li><li><p>注意：CMS 作为老年代的收集器，新生代只能选择 ParNew 或者 Serial 收集器的一个。</p></li></ul><blockquote><h2 id="cms的工作原理"><a class="anchor" href="#cms的工作原理">#</a> CMS 的工作原理</h2></blockquote><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始表示阶段、并发标记阶段、重新标记阶段和高并发清除阶段</p><ol><li><mark>初始标记阶段 (Initial-Mark)</mark>: 在这个阶段中，程序中的所有工作线程都会因为 STW 机制而出现短暂的暂停，这个阶段的主要任务仅仅是标记处 GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li><mark>并发标记阶段 (Concurrent-Mark) 阶段</mark>：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li><mark>重新标记阶段 (Remark)</mark>: 由于在并发标记中，程序的工作线程会和垃圾收集线程同时运行或交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停顿时间常常会比初始标记阶段稍长一些，但是也远比并发标记阶段的时间短</li><li><mark>并发清除阶段 (Concurrent-Sweep) 阶段</mark>：此极端清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发。</li></ol><p>由于 CMS 收集器的垃圾收集算法采用的是标记 - 清除算法，这就意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞技术，而只能够选择空闲列表执行内存分配。</p><blockquote><h3 id="既然mark-sweep会造成内存碎片为什么不把算法换成mark-compact呢"><a class="anchor" href="#既然mark-sweep会造成内存碎片为什么不把算法换成mark-compact呢">#</a> 既然 Mark-Sweep 会造成内存碎片，为什么不把算法换成 Mark Compact 呢？</h3></blockquote><p>因为并发清除的时候，用 compact 整理内存的话，原来的用户线程使用的内存还怎么用？要保证用户线程继续执行，前提是他运行的资源不受影响。Mark Compact 更适合在 STW 场景下使用。</p><blockquote><h5 id="弊端"><a class="anchor" href="#弊端">#</a> 弊端</h5></blockquote><ol><li>会产生内存碎片</li><li>CMS 收集器对 CPU 资源非常敏感</li><li>CMS 收集器无法处理浮动垃圾 (如果在并发标记阶段产生了新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些垃圾对象没有被及时回收)</li></ol><blockquote><h2 id="参数"><a class="anchor" href="#参数">#</a> 参数</h2></blockquote><p><mark>-XX:+UserConcMarkSweepGC</mark>: 手动指定使用 CMS 收集器执行内存回收任务，开启该参数后会自动将 ParNewGC 打开</p><h2 id="g1回收器区域分代化"><a class="anchor" href="#g1回收器区域分代化">#</a> G1 回收器：区域分代化</h2><p>官方给 G1 设定的目标是在延迟可控的情况下获取尽可能高的吞吐量，所以才担起全功能收集器的重任与期望</p><p>G1 是一个并行回收器，它把堆内存分割为很多不相关的区域 (Region)(物理上不连续). 使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等</p><p>G1 有计划地避免在整个 Java 堆中进行全区域的垃圾收集.G1 跟踪各个 Region 里面的垃圾堆积的价值大小 (回收所获得的空间大小以及回收所需要的经验值), 在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><blockquote><h2 id="优点-3"><a class="anchor" href="#优点-3">#</a> 优点</h2></blockquote><ul><li><p>并行与并发</p><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li><p>分代收集</p><ul><li>从分代上看，G1 依然属于分代垃圾回收器，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区，但从堆的结构上来看，它不要求整个 Eden 区、年轻代或者老年代是连续的，也不再坚持固定大小和固定数量</li><li>将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代</li><li>和之前的各类垃圾回收器不同，它兼顾年轻代和老年代。</li></ul></li><li><p>空间整合</p></li></ul><p>G1 将内存划分为一个个 region, 内存回收是以 region 作为基本单位的。Region 之间是复制算法，但整体上可以看作是标记 - 压缩算法。</p><ul><li>可预测的停顿时间模型</li></ul><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求地低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不超过 N 毫秒</p><p>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制</p><p>G1 跟踪各个 Region 里面的垃圾堆积价值大小，在后台维护一个优先列表，每次根据允许收集的时间，优先回收价值最大的 Region. 保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率</p><blockquote><h2 id="分区region化整为零"><a class="anchor" href="#分区region化整为零">#</a> 分区 Region: 化整为零</h2></blockquote><ul><li>一个 region 有可能属于 Eden,Surivor 或者 Old/Tenured 内存区域。但是一个 region 只可能属于一个角色。</li><li>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 region, 就放到 H</li></ul><blockquote><h1 id="设置h的原因"><a class="anchor" href="#设置h的原因">#</a> 设置 H 的原因</h1></blockquote><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humogous 区，它用来专门存放大对象，如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储，为了能找到连续的 H 区，有时候不得不启动 FullGC,G1 的大多数行为都把 H 区作为老年代的一部分来看待</p><blockquote><h2 id="g1回收器垃圾回收过程"><a class="anchor" href="#g1回收器垃圾回收过程">#</a> G1 回收器垃圾回收过程</h2></blockquote><ul><li>年轻代 GC</li><li>老年代并发标记过程</li><li>混合回收</li></ul><ol><li><p>应用程序分配内存，当年轻代的 Eden 区用尽开始年轻代回收过程：G1 的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC 暂停所有应用程序线程，启动多线程执行年轻代回收，然后从年轻代区间移动存货对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及</p></li><li><p>当堆内存使用达到一定值 (默认 45%) 时，开始老年代并发标记过程</p></li><li><p>当标记完成马上开始混合回收过程，对于一个混合回收期，G1 GC 从老年代区间移动存活对象到空闲区间，这些空闲区间也就成了老年代的一部分，和年轻代不同，老年代的 G1 回收器和其他 GC 不同，G1 的老年代回收器不需要整个老年代被回收，一次需要扫描 / 回收一小部分老年代 Region 就可以了，同时，这个老年代 Region 是和年轻代一起被回收的。</p></li></ol><h2 id="gc日志分析"><a class="anchor" href="#gc日志分析">#</a> GC 日志分析</h2><blockquote><h2 id="内存分配与垃圾回收的参数列表"><a class="anchor" href="#内存分配与垃圾回收的参数列表">#</a> 内存分配与垃圾回收的参数列表</h2></blockquote><ul><li><p>-XX:+PrintGC 输入 GC 日志</p></li><li><p>-XX:+PrintGCDetail 输出 GC 的详细日志</p></li><li><p>-XX:+PrintGCTimeStamps 输出 GC 的时间戳 (以基准时间的形式)</p></li><li><p>-XX:+PrintGCDateStamps 输出 GC 的时间戳 (以日期形式)</p></li><li><p>-XX:+PrintHeadAtGC 在进行 GC 前后打印出堆的信息</p></li><li><p>-Xloggc:../logs/gc.log 日志文件输出的路径</p></li></ul><h2 id="fullgc的理解"><a class="anchor" href="#fullgc的理解">#</a> FullGC 的理解</h2><hr><ul><li>SerialGC<ul><li>新生代内存不足发生的垃圾收集 - minor GC</li><li>老年代内存空间不足发生的垃圾收集 - full GC</li></ul></li><li>ParallelGC<ul><li>新生代内存不足发生的垃圾收集 -minor gc</li><li>老年代内存不足发生的垃圾收集 -full gc</li></ul></li><li>CMS<ul><li>新生代内存不足发生的垃圾收集 -minor gc</li><li>老年代内存不足</li></ul></li><li>G1<ul><li>新生代内存不足发生的垃圾收集 -minor gc</li><li>老年代内存不足</li></ul></li></ul><h1><a class="anchor" href="#">#</a></h1><div class="tags"><a href="/tags/jvm/" rel="tag"><i class="ic i-tag"></i> jvm</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-10-21 20:15:07" itemprop="dateModified" datetime="2021-10-21T20:15:07+08:00">2021-10-21</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>故犹 <i class="ic i-at"><em>@</em></i>努力走,走到灯火通明</li><li class="link"><strong>本文链接：</strong> <a href="https://guyouwyh.github.io/guyouwyh/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm6/" title="JVM笔记(六)-垃圾回收">https://guyouwyh.github.io/guyouwyh/2021/10/21/后端/Java/jvm6/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm5/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2021&#x2F;12&#x2F;15&#x2F;sE4YZtNxHrPTG8c.jpg" title="JVM笔记(五)-字符串常量池"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础</span><h3>JVM笔记(五)-字符串常量池</h3></a></div><div class="item right"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm7/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2021&#x2F;12&#x2F;15&#x2F;Q7NJ3nA9i2KwjfG.jpg" title="JVM笔记(七)-字节码指令"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java基础</span><h3>JVM笔记(七)-字节码指令</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#gc"><span class="toc-number">1.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BEgarbage"><span class="toc-number">1.1.</span> <span class="toc-text">什么是垃圾 (Garbage)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.</span> <span class="toc-text">垃圾标记阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E6%96%AD"><span class="toc-number">1.3.</span> <span class="toc-text">垃圾标记阶段：对象存活判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">引用计数算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc-roots"><span class="toc-number">1.6.</span> <span class="toc-text">GC Roots</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalization%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.</span> <span class="toc-text">finalization 机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="toc-number">1.8.</span> <span class="toc-text">垃圾清除阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4mark-sweep%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">标记 - 清除 (Mark-Sweep) 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95copying"><span class="toc-number">1.8.2.</span> <span class="toc-text">复制算法 (Copying)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.9.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.10.</span> <span class="toc-text">缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9mark-compact%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.1.</span> <span class="toc-text">标记 - 压缩 (Mark-Compact) 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">1.11.</span> <span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.11.1.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.12.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">1.13.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.14.</span> <span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systemgc"><span class="toc-number">1.15.</span> <span class="toc-text">System.gc()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAoom"><span class="toc-number">1.16.</span> <span class="toc-text">内存溢出 (OOM)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.17.</span> <span class="toc-text">没有空闲内存的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2memory-leak"><span class="toc-number">1.18.</span> <span class="toc-text">内存泄露 (Memory Leak)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stop-the-world"><span class="toc-number">1.19.</span> <span class="toc-text">Stop The World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.20.</span> <span class="toc-text">垃圾回收的并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-number">1.21.</span> <span class="toc-text">安全点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9Fsafe-region"><span class="toc-number">1.22.</span> <span class="toc-text">安全区域 (Safe Region)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.23.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8strongreference"><span class="toc-number">1.24.</span> <span class="toc-text">强引用 (StrongReference)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8softreference-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%9B%9E%E6%94%B6"><span class="toc-number">1.25.</span> <span class="toc-text">软引用 (SoftReference)- 内存不足回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8weakreference-%E5%8F%91%E7%8E%B0%E6%89%8D%E5%9B%9E%E6%94%B6"><span class="toc-number">1.26.</span> <span class="toc-text">弱引用 (WeakReference)- 发现才回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8phantomreference-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E8%B7%9F%E8%B8%AA"><span class="toc-number">1.27.</span> <span class="toc-text">虚引用 (PhantomReference)- 对象引用跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8final-reference"><span class="toc-number">1.28.</span> <span class="toc-text">终结器引用 (Final reference)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.29.</span> <span class="toc-text">垃圾回收的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.30.</span> <span class="toc-text">性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E7%A7%8D%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.31.</span> <span class="toc-text">七种经典垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.32.</span> <span class="toc-text">查看默认的垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#serial%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">1.32.1.</span> <span class="toc-text">Serial 回收器：串行回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.32.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parnew%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">1.32.2.</span> <span class="toc-text">ParNew 回收器：并行回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parallel-scavenge%E5%9B%9E%E6%94%B6%E5%99%A8%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">1.32.3.</span> <span class="toc-text">Parallel Scavenge 回收器：吞吐量优先</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">参数配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cms%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="toc-number">2.0.1.</span> <span class="toc-text">CMS 回收器：低延迟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cms%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">CMS 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A2%E7%84%B6mark-sweep%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8A%E7%AE%97%E6%B3%95%E6%8D%A2%E6%88%90mark-compact%E5%91%A2"><span class="toc-number">2.1.1.</span> <span class="toc-text">既然 Mark-Sweep 会造成内存碎片，为什么不把算法换成 Mark Compact 呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%8A%E7%AB%AF"><span class="toc-number">2.1.1.0.1.</span> <span class="toc-text">弊端</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g1%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8C%BA%E5%9F%9F%E5%88%86%E4%BB%A3%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">G1 回收器：区域分代化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">2.4.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BAregion%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6"><span class="toc-number">2.5.</span> <span class="toc-text">分区 Region: 化整为零</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEh%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.</span> <span class="toc-text">设置 H 的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#g1%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">G1 回收器垃圾回收过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">GC 日志分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">内存分配与垃圾回收的参数列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fullgc%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.4.</span> <span class="toc-text">FullGC 的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text"></span></a></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%80)/" rel="bookmark" title="Java面向对象(一)">Java面向对象(一)</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%BA%8C)/" rel="bookmark" title="Java面向对象(二)">Java面向对象(二)</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/IO%E6%B5%81/" rel="bookmark" title="JavaIO流">JavaIO流</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/%E5%8F%8D%E5%B0%84/" rel="bookmark" title="Java反射">Java反射</a></li><li><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" rel="bookmark" title="Java8新特性">Java8新特性</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" rel="bookmark" title="Java异常处理">Java异常处理</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="bookmark" title="Java的常用类">Java的常用类</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm1/" rel="bookmark" title="JVM笔记(一)-概述">JVM笔记(一)-概述</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm2/" rel="bookmark" title="JVM笔记(二)-类加载器">JVM笔记(二)-类加载器</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm3/" rel="bookmark" title="JVM笔记(三)-运行时数据区">JVM笔记(三)-运行时数据区</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm4/" rel="bookmark" title="JVM笔记(四)-执行引擎">JVM笔记(四)-执行引擎</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm5/" rel="bookmark" title="JVM笔记(五)-字符串常量池">JVM笔记(五)-字符串常量池</a></li><li class="active"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm6/" rel="bookmark" title="JVM笔记(六)-垃圾回收">JVM笔记(六)-垃圾回收</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm7/" rel="bookmark" title="JVM笔记(七)-字节码指令">JVM笔记(七)-字节码指令</a></li><li><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm8/" rel="bookmark" title="JVM笔记(八)-类加载的三个阶段">JVM笔记(八)-类加载的三个阶段</a></li><li><a href="/2021/10/23/%E5%90%8E%E7%AB%AF/Java/Java%E6%B3%A8%E8%A7%A3/" rel="bookmark" title="Java注解">Java注解</a></li><li><a href="/2021/10/23/%E5%90%8E%E7%AB%AF/Java/Java%E6%9E%9A%E4%B8%BE/" rel="bookmark" title="Java枚举">Java枚举</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="故犹" data-src="/images/avatar.jpg"><p class="name" itemprop="name">故犹</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">119</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">32</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">71</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2d1eW91d3lo" title="https:&#x2F;&#x2F;github.com&#x2F;guyouwyh"><i class="ic i-github"></i></span> <a href="/821403296@qq.com" title="821403296@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-link"></i>友链</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-magic"></i>常用网站</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm5/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/Java/jvm7/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/JavaWeb/" title="分类于 JavaWeb">JavaWeb</a></div><span><a href="/2021/10/21/%E5%90%8E%E7%AB%AF/JavaWeb/JSP/" title="JSP模板引擎基本使用">JSP模板引擎基本使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java基础">Java基础</a></div><span><a href="/2021/10/23/%E5%90%8E%E7%AB%AF/Java/Java%E6%9E%9A%E4%B8%BE/" title="Java枚举">Java枚举</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/2021/11/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/" title="【力扣】376.摆动序列">【力扣】376.摆动序列</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="分类于 单调队列">单调队列</a></div><span><a href="/2022/02/23/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/%E5%AF%BB%E6%89%BE%E6%AE%B5%E8%90%BD/" title="【洛谷】P1419 寻找段落">【洛谷】P1419 寻找段落</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%90%8E%E7%AB%AF/" title="分类于 后端">后端</a> <i class="ic i-angle-right"></i> <a href="/categories/%E5%90%8E%E7%AB%AF/Java/" title="分类于 Java基础">Java基础</a></div><span><a href="/2021/10/20/%E5%90%8E%E7%AB%AF/Java/%E5%8F%8D%E5%B0%84/" title="Java反射">Java反射</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/2021/11/06/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/" title="【力扣】322.零钱兑换">【力扣】322.零钱兑换</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6/" title="分类于 归并">归并</a></div><span><a href="/2022/02/24/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6/%E9%80%86%E5%BA%8F%E5%AF%B9/" title="【洛谷】P1908 逆序对">【洛谷】P1908 逆序对</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/2021/11/06/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0IV/" title="【力扣】377.组合总数">【力扣】377.组合总数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/" title="分类于 搜索">搜索</a></div><span><a href="/2021/11/10/%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/" title="【力扣】124.二叉树中的最大路径和">【力扣】124.二叉树中的最大路径和</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%AE%97%E6%B3%95/" title="分类于 算法">算法</a> <i class="ic i-angle-right"></i> <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="分类于 动态规划">动态规划</a></div><span><a href="/2021/11/01/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/" title="【力扣】413.等差数列的划分">【力扣】413.等差数列的划分</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">故犹 @ GuYou</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">485k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">7:21</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/10/21/后端/Java/jvm6/",favicon:{show:"加载中",hide:"OvO"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->